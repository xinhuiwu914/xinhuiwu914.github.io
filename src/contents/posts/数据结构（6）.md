---
title: 数据结构-6 #标题
published: 2025-06-02 #发布日期
description: 数据结构学习 #描述
tags: [Markdown, Blogging] #标签
category: 笔记 #分类
draft: false #是否为草稿 （隐藏）
---

# 图

## 6.1图的基本概念

### 6.1.1图的定义

- 组成要素：图G由顶点集V和边集E组成，记为G=(V,E)

- 顶点集特性：

  - ﻿V(G)必须是非空有限集
  - 顶点个数|V|称为图的阶

- 边集特性：

  - ﻿
    $$
    E=\{(u,v)|u\in V,v\in V\}
    $$

  - 边数用|E|表示

  - 允许空边集（零图）

- 重要限制：

  - 边必须连接两个有效顶点（不能有游离边）
  - 区别于线性表和树，图不允许"空图"

#### 1.有向图

- 边特性：边有方向，
  $$
  <v,w>\not\equiv<w,v>
  $$
  术语：

  - 称为有向边或"弧"
  - 弧尾：边的起始顶点
  - 弧头：边的指向顶点

- 数学表示：

  - 无向边：圆括号(v,w)
  - 有向边：尖括号<v,w>

#### 2.无向图

- 边特性：边无方向，
  $$
  (v,w)\equiv(w,v)
  $$

- 术语：称为无向边或简称"边"

#### 3.简单图、多重图

- 简单图：
  - 限制条件：
    - 不存在重复边
    - 不存在顶点到自身的边（自环）
- 多重图：
  - 允许情况：
    - 两个顶点间可有多条同向边
    - 允许顶点自环边

#### 4.顶点的度、入度和出度

- 无向图顶点度：指依附于该顶点的边的数量，记作TD(v)，其中v

  表示特定顶点。

- 有向图入度：指向该顶点的箭头数量。如顶点A的入度为1。

- 有向图出度：从该顶点向外发射的箭头数量。如顶点A的出度为4。

- 有向图总度：入度与出度之和。如顶点A的总度为1+4=5。

- 无向图度总和：所有顶点度之和等于边数的2倍（每条边贡献2个度）。

- 有向图度关系：所有顶点入度之和=出度之和=弧的数量。

#### 5.路径、路径长度和回路

##### 1）路径

- 定义：
  $$
  顶点﻿v_p﻿到v_q﻿的路径是指顶点序列﻿v_p,v_{i_1},v_{i_2},...,v_{i_m},v_q﻿。
  $$

- 无向图路径：方向无限制（如A-B-E-D或A-B-D）。

- 有向图路径：必须与弧方向一致（如A→B→E可，但E→A不可）。

- 特例：某些顶点间可能不存在路径（如图中F与其他顶点）。

##### 2）回路

- 定义：第一个顶点与最后一个顶点相同的路径（如B-D-E-B或A→B→C→D→A）。

##### 3）路径长度

- 计算方式：路径包含的边数（如A-B-D长度为2，A-B-E-D长度为3）。

#### 6.简单路径、简单回路

- 简单路径：顶点不重复的路径（如A-B-E-D）。
- 非简单路径：顶点重复的路径（如A-B-E-B-D）。
- 简单回路：除首尾顶点外，其余顶点不重复的回路。

#### 7.距离

- 定义：两顶点间最短路径的长度（如A-D距离为2）。
- 特殊情况：无路径时记为无穷（如E→A距离为∞）。
- 无向图特性：A到D距离=D到A距离。
- 有向图特性：距离可能不对称（A→E距离为1，E→A为∞）。

#### 8.子图

- 定义：设有两个图G=(V,E)和G'=(V',E')，若V'是V的子集，且E'是E的子集，则称G'是G的子图。
- 构成条件：必须满足图的定义，即子图中每条边的两个顶点都必须包含在顶点子集V'中。例如不能只选边而不选其关联顶点。
- 生成子图：当子图G'满足V(G')=V(G)时（即包含原图所有顶点），称为生成子图。生成子图可以通过去掉原图部分边得到。
- 适用范围：子图和生成子图概念同样适用于有向图，定义条件与无向图完全一致。

#### 9.联通、连通图和联通分量

- 无向图连通：两顶点间存在路径即为连通（如图中F与其他顶点不连通）。
- 有向图强连通：需双向存在路径（如A与B强连通，A与E不强连通）。

###### 连通图

- ##### 定义：若图G中任意两个顶点都是连通的，则称图G为连通图，否则称为非连通图。

- 最小边数：对于具有n个顶点的无向图，保证连通的最少边数为n-1条。例如5个顶点需要4条边即可连通。

- 最大非连通边数：要使n个顶点的无向图保持非连通，最多可有
  $$
  C_{n-1}^2
  $$
  条边。例如5个顶点时，最多可有
  $$
  C_4^2=6
  $$
  条边（其中4个顶点完全连接），再多加任一条边都会使图变为连通。



##### 连通分量

- 定义：无向图中的极大连通子图称为连通分量。

- 特性：

  - 连通性：子图内部任意两顶点间存在路径

  - 极大性：包含尽可能多的顶点和边（无法再扩展）

    ​	

#### 10.强连通图、强连通分量

- 定义：对于有向图，若任意一对顶点之间都是强连通的（双向可达），则该有向图称为强连通图。
- 最小边数：具有n个顶点的有向图要保证强连通，最少需要n条边构成一个回路。例如5个顶点形成环状回路时，从任一顶点出发均可到达其他所有顶点。

> 连通图专指无向图，强连通图专指有向图。



##### 强连通分量

- 定义：有向图中的极大强连通子图称为强连通分量。

- 判断标准：子图中任意两顶点u,v间存在双向路径（u→v且v→u）

  > 与无向图的区别：强连通分量要求双向可达性，比无向图的连通性要求更严格。

#### 11.生成树、生成森林

##### 生成树

- 定义：连通图的生成树是包含图中全部顶点的一个极小连通子图。
- 特性：
  - 顶点全覆盖：包含原图所有顶点
  - 边数最少：若图有n个顶点，则生成树有n-1条边
  - 唯一性：一个连通图可能有多个不同的生成树
- 操作特性：
  - 删除任意一条边会导致图不连通
  - 添加任意一条边会形成回路



##### 生成森林

- 定义：非连通图中，各连通分量的生成树的集合称为生成森林。
- 构造方法：
  - 将非连通图分解为多个连通分量
  - 为每个连通分量构造生成树
  - 所有生成树的集合即为生成森林



#### 12.边的权、网和带权路径长度

##### 边的权、网

- 权值概念：为图的边赋予的数值，表示距离、成本等实际意义
- 应用场景：在生成树应用中，需要结合边权值寻找最小成本方案

- 边的权值：在图中每条边可以标上具有特定含义的数值（如距离、概率等），该数值称为边的权值。例如地图中边的权值可表示两地距离（北京-天津200公里，天津-上海600公里）。
- 带权图/网：边上带有权值的图称为带权图，也称为网。权值的具体含义取决于实际问题（如社交网络中可表示信息转发概率）。



##### 带权路径长度

路径上所有边的权值之和。



#### 13.完全图（也称简单完全图）

##### 无向完全图

- 定义：无向图中任意两个顶点间都存在边。对于n个顶点的图，边数
  $$
  |E| \in [0, C_n^2]，其中C_n^2 = n(n-1)/2
  $$
  为最大边数。

- 有向完全图：任意两个顶点间存在方向相反的两条弧，边数为
  $$
  2C_n^2 = n(n-1)。
  $$

#### 14.稠密图、稀疏图

区分标准：边数远少于最多可能边数的图称为稀疏图，反之称为稠密图。经验判断：当
$$
|E|<|V|\log|V|
$$
时可视为稀疏图（无绝对界限）。

#### 15.有向树

- 特性：无回路且连通的无向图。n个顶点的树必有n-1条边。
- 重要结论：若n顶点图的|E|>n-1，则必存在回路。
- 森林：由多棵互不连通的树组成的图。



##### 有向树

- 定义：有向图中一个顶点入度为0（根节点），其余顶点入度均为1。例如微博大V的粉丝关系可形成有向树结构。
- 与无向树区别：有向树不要求强连通性，但具有明确的层级关系。



## 6.2图的存储及基本操作

### 6.2.1邻接矩阵法

##### 1）无向图 

- ![img](https://thumbnail0.baidupcs.com/thumbnail/58b18d5a2ie7c4a1509a6b3748fc5ca9?chkbd=0&chkv=0&dp-callid=0&dp-logid=693556594540887104&expires=8h&fid=1103289404712-250528-1119783519929769&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-uBT%2F9d0v%2FsCpBMrs%2BcO0XIn8N%2BQ%3D&size=c1080_u1080&time=1748829600&vuk=1103289404712)

- 存储原理：用n x n矩阵表示n个顶点的图，矩阵元素
  $$
  A[i][j]=1表示顶点v_i与v_j之间存在边，0表示无边。
  $$

- 无向图特性：每条边在矩阵中对应两个1（如a-b边会使A[a][b]和A[b][a]都为1），矩阵具有对称性。

- 示例：对于无向图a-b,a-c,a-d，a行b/c/d列均为1，a-e为0。

##### 2）有向图 ﻿

- 有向边表示：弧a→b
  $$
  仅在A[a][b]=1，而A[b][a]保持为0。
  $$

- 区别：每条有向边只对应矩阵中的一个1（不同于无向图的两个1）。

##### 3）求顶点的度、入度、出度 ﻿

- 无向图度：等于对应行/列非零元素个数（时间复杂度O(|V|)）。例如顶点b的度为3。
- 有向图：
  - 出度：对应行非零元素个数（如a的出度为检查a行）
  - 入度：对应列非零元素个数（如a的入度为检查a列）
  - 总度：入度+出度



##### 1.无向图

- 存储原理：用n x n矩阵表示n个顶点的图，
  $$
  矩阵元素A[i][j]=1表示顶点v_i与v_j之间存在边，0表示无边。
  $$
  

- 无向图特性：每条边在矩阵中对应两个1
  $$
  （如a-b边会使A[a][b]和A[b][a]都为1），矩阵具有对称性。
  $$

##### 2.有向图

- 有向边表示：
  $$
  弧a→b仅在A[a][b]=1，而A[b][a]保持为0。
  $$

- 区别：每条有向边只对应矩阵中的一个1（不同于无向图的两个1）。



##### 3.求顶点的度、入度、出度

- 无向图度：等于对应行/列非零元素个数（时间复杂度O(|V|)）。例如顶点b的度为3。
- 有向图：
  - 出度：对应行非零元素个数（如a的出度为检查a行）
  - 入度：对应列非零元素个数（如a的入度为检查a列）
  - 总度：入度+出度



##### 4.邻接矩阵法存储带权图

- 权值表示：边存在时存储权值，无边时用INFINITY（如int最大值）表示。
- 特殊处理：允许对角线元素为0表示自环边不存在。



##### 5.邻接矩阵法的性能分析

- 空间复杂度：
  $$
  O(|V|^2)，含顶点数组O(|V|)和边矩阵O(|V|^2)。
  $$

- 适用场景：适合稠密图，稀疏图会浪费空间。

- 压缩存储：无向图可只存下三角区，利用对称矩阵压缩技术（存储空间减半）。



##### 6.邻接矩阵法的性质

路径计数：邻接矩阵A的n次方中
$$
A^n[i][j]
$$
表示顶点i到j长度为n的路径数量。



### 6.2.2邻接表法

- 实现原理：
  - 顶点存储：一维数组存储顶点信息，包含数据域和指向第一条边的指针
  - 边节点结构：包含邻接顶点编号和权值（带权图），通过指针形成链表
  - 图声明要素：需记录顶点数（MaxVertexNum）和边数
- 与树结构对比：类似树的"孩子表示法"，均采用顺序存储节点+链式存储关联关系



#### 1. 求一个顶点的度或入度及出度

- 无向图操作：
  - 求度：遍历边链表，边节点数量即为度
  - 找相邻边：直接遍历边链表即可获得所有邻接边
- 有向图操作：
  - 求出度：遍历边链表，节点数即为出度
  - 求入度缺陷：必须遍历所有顶点的边链表，时间复杂度达O(|V|+|E|)
- 空间复杂度差异：
  - 无向图O(|V|+2|E|)（每条边存储两次）
  - 有向图O(|V|+|E|)



#### 2. 邻接表法的表示方式

- 表示非唯一性：边节点在链表中的顺序可任意调整（如0号顶点边链表可用1→2→3或3→2→1顺序）
- 与邻接矩阵对比：
  - 邻接矩阵表示唯一（固定顶点编号对应固定矩阵）
  - 邻接表更适合稀疏图存储



> $$
> 邻接表O(|V|+|E|)显著优于邻接矩阵O(|V|^2)
> $$

## 6.3 图的遍历

### 6.3.1广度优先搜索

- 基本思想：从根节点出发，先访问相邻的所有节点，再依次从这些节点出发访问下一层节点。
- 横向搜索：优先横向扩展搜索范围，因此称为"广度优先"。
- 实现特点：树结构不存在环路，每个新发现的节点都是未访问过的。
- 分层访问：与树类似，按层次逐步向外扩展访问。



#### 树与图的广度优先遍历的联系和区别

- 共同点：
  - 都需要实现"找到与一个顶点相邻的所有顶点"的操作
  - 都采用分层遍历的思想
- 关键区别：
  - 环路处理：树不存在环路，而图可能存在环路
  - 重复访问：图中需要通过标记数组避免重复访问已处理节点



#### 广度优先遍历（BFS）算法介绍

- 关键操作：

  - NextNeighbor(G,x,y)：返回图G中顶点x的下一个邻接点（除y外），若y是最后一个则返回-1
  - 访问标记：使用布尔数组visited[MAX_VERTEX_NUM]记录节点访问状态

  - 辅助队列：需要队列暂存待处理的节点（与树的层序遍历相同）

    

#### BFS算法

遍历序列的可变性

- 存储结构影响：
  - 邻接矩阵：遍历序列唯一，因为邻接矩阵表示方式唯一（总是按顶点编号顺序存储）
  - 邻接表：遍历序列不唯一，取决于邻接表中边的存储顺序（如顶点2的邻接表可存储为1→6或6→1）
- 实现差异：
  - 邻接矩阵查找相邻顶点时总是按编号顺序
  - 邻接表查找顺序取决于具体实现方式

- 非连通图的问题与处理 

  - 问题描述：标准BFS算法无法遍历非连通图中所有顶点（如新增的9、10、11号顶点）
  - 解决方案：多次调用BFS函数
    - 使用visit数组记录访问状态
    - 每次调用BFS后检查未访问顶点
    - 从未访问顶点开始新一轮BFS

- 实现细节：初始化与扫描 

  - 初始化步骤：

    - 将visit数组全部设为FALSE
    - 初始化辅助队列

  - 扫描过程：

    - 使用for循环扫描visit数组
    - 找到第一个值为FALSE的顶点作为新起点
    - 调用BFS函数进行遍历

  - 连通分量判定：

    - 调用BFS的次数等于图的连通分量数量
    - 每个连通分量对应一个极大连通子图

    > 注意事项：
    >
    > 顶点编号从0开始或1开始会影响具体实现
    >
    > 核心是确保扫描到所有未访问顶点



#### 复杂度分析

- ##### BFS算法的空间复杂度 

  - 主要来源: 辅助队列的空间消耗
  - 最坏情况: 当从某个顶点出发时，所有其他顶点都与其相邻（如星型图），此时辅助队列需要存储O(|V|)个顶点

- ##### BFS算法的时间复杂度 

  - 主要开销: 包含两部分：访问各个顶点的时间 + 探索各条边的时间
  - 总体原则: 时间复杂度分析应分别计算顶点访问和边探索的开销，再根据存储结构具体分析

- ##### 邻接矩阵存储图的时间复杂度 

  - 顶点访问: 需要O(|V|)时间访问所有顶点
  - 边探索:
    - 查找每个顶点的邻接点都需要遍历整行，耗时O(|V|)
    - 共|V|个顶点，总时间O(|V|^2)
  - 合计:O(|V|^2)（高阶项主导）

- ##### 邻接表存储图的时间复杂度 

  - 顶点访问: 需要O(|V|)时间
  - 边探索:
    - 无向图需访问2|E|个边节点（每条边存储两次）
    - 时间复杂度为O(|E|)（忽略常数系数2）
  - 合计:O(|V|+|E|)
  - 极端情况: 当图为零图（无边）时，仍需O(|V|)时间访问所有顶点

- ##### 算法时间复杂度分析建议 

  - 分析方法: 不建议仅分析最深层循环次数，而应拆分为：
    - 顶点访问时间
    - 边探索时间
  - 适用性: 该方法同样适用于深度优先搜索(DFS)的复杂度分析
  - 记忆技巧: 复杂度取决于"访问顶点+探索边"的组合开销，具体数值由存储结构决定



#### 广度优先生成树

定义：在图的广度优先遍历过程中，记录每个顶点第一次被访问时的边（标红边），由这些n-1条边构成的子图称为广度优先生成树。

##### 唯一性：

- 邻接表存储：由于邻接表表示方式不唯一，导致生成的广度优先生成树可能不唯一。
- 邻接矩阵存储：表示方式唯一，因此广度优先生成树必然唯一。



#### 广度优先生成森林

定义：对非连通图进行广度优先遍历时，每个连通分量生成一棵广度优先生成树，所有生成树的集合称为广度优先生成森林。



### 6.3.2深度优先搜索

#### 1. 树的深度优先遍历

##### 1）先根遍历

- 递归实现：树的先根遍历采用递归算法，先访问根节点，再递归遍历各子树。例如访问顺序：1→2→5→6→3→4→7→8。
- 特性：由于树结构的特殊性，新探索的相邻节点必定未被访问过，无需额外标记。



##### 2）图的深度优先遍历

- 与树的区别：需要visited数组标记访问状态，防止重复访问。算法结构与树先根遍历类似，但增加了邻接顶点检查逻辑。
- 执行过程示例：从顶点2出发的遍历序列为2→1→5→6→3→4→7→8，通过递归深入未访问邻接点。



##### 3）算法存在的问题

- 局限性：基础DFS无法遍历非连通图所有顶点，如示例中顶点9-11会被遗漏。
- 解决方法：外层增加for循环扫描visited数组，对未访问顶点再次调用DFS。



##### 4）DFS算法 

- 完整实现：
  - 初始化visited数组为FALSE
  - 循环检查各顶点，对未访问顶点调用DFS
  - DFS内部递归访问邻接未访问顶点
- 非连通图处理：通过多次调用DFS覆盖所有连通分量。



#### 2. 复杂度分析

- 空间复杂度：
  - 最坏O(|V|)（递归深度等于顶点数）
  - 最好O(1)（如链式图仅需常数栈空间）
- 时间复杂度：
  - 邻接矩阵：O(|V|^2)
  - 邻接表：O(|V|+|E|)



#### 3. 深度优先遍历序列

- 邻接矩阵：表示唯一，遍历序列确定。
- 邻接表：表示不唯一导致遍历序列不唯一。



#### 4. 深度优先生成树

- 定义：保留DFS探索边的树结构，去掉回边（已访问顶点的边）。
- 非唯一性：邻接表存储时生成树不唯一，对应不同遍历序列。
- 生成森林：非连通图产生多棵生成树组成森林。



#### 5. 图的遍历和图的连通性

- 无向图：调用DFS/BFS次数=连通分量数。
- 有向图：
  - 强连通图：从任一点出发只需1次调用
  - 非强连通：需具体分析路径存在性



## 6.4图的应用

### 6.4.1最小生成树

#### 1. 最小生成树的概念

##### 1）生成树

- 定义：对于连通无向图，生成树是包含图中全部顶点的一个极小连通子图，具有n-1条边（n为顶点数）。
- 特性：
  - 砍去任意一条边会变成非连通图
  - 增加任意一条边会形成回路
  - 可通过广度优先遍历或深度优先遍历确定不同形态的生成树



##### 2）最小生成树

- 定义：对于带权连通无向图G=(V,E)，所有生成树中边权值之和最小的生成树称为最小生成树（Minimum-Spanning-Tree, MST）。
- 性质：
  - 最小生成树可能不唯一，但权值之和总是唯一且最小的
  - 边数恒为顶点数减1（n-1条边）
  - 连通图本身就是树时，其最小生成树就是它本身
  - 仅连通图才有生成树，非连通图只有生成森林



#### 2. Prim算法

##### 1）Prim算法的基本步骤 

- 核心思想：从任意顶点开始，每次选择代价最小的新顶点纳入生成树，直到所有顶点都纳入。
- 执行过程：
  - 选择起始顶点
  - 在未连接的顶点中，选择与当前生成树连接代价最小的顶点
  - 重复步骤2直到所有顶点都连接



##### 2）最小生成树可能不唯一



#### 3.Kruskal算法

- ![img](https://thumbnail0.baidupcs.com/thumbnail/1e5316d25qbd1d8cbb4b369a54de3712?chkbd=0&chkv=0&dp-callid=0&dp-logid=2949834370905653646&expires=8h&fid=1103289404712-250528-902740192417240&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-mnBRguix486NOMn6e0DtveXtw2c%3D&size=c1080_u1080&time=1748851200&vuk=1103289404712)
- 核心思想：每次选择权值最小的边，若该边的两个顶点未连通则选中，直到所有结点连通为止。
- 执行步骤：
  - 初始时所有顶点独立存在（虚线连接）
  - 选择权值最小边（如学校和P城边权1）
  - 检查边两端顶点连通性（未连通则选中）
  - 重复步骤2-3（后续依次选择边权2、3、4的边）
  - 遇到已连通顶点则跳过（如边权4的P城-渔村边）
- 示例说明：在示例图中最终得到的最小生成树总代价为15，与Prim算法结果一致。



#### 4. Prim算法与Kruskal算法的比较

- 基本区别：

  - Prim：从顶点出发构建，每次纳入新顶点
  - Kruskal：从边出发构建，每次选择最小边

- 适用场景：

  - Prim：适合边稠密图
    $$
    （O(|V|^2)时间复杂度）
    $$

  - Kruskal：适合边稀疏图
    $$
    （O(|E|\log_2|E|)时间复杂度）
    $$
    

##### 1）Prim算法的实现思想

- 数据结构：

  - isJoin[]数组：记录顶点是否加入生成树
  - lowCost[]数组：记录加入生成树的最小代价

- 执行流程：

  - $$
    初始化选择起点（如v_0）
    $$

  - 每轮选择未加入顶点中lowCost最小的顶点

  - 更新相邻顶点的lowCost值
    $$
    （如v_3加入后，v_1的代价从6更新为5）
    $$

  - 共需n-1轮处理，每轮时间复杂度O(2n)

- 时间复杂度分析：总时间复杂度O(n^2)，主要来自嵌套循环结构。

  

##### 2）Kruskal算法的实现思想

- 关键步骤：

  - 将所有边按权值排序（预处理）
  - 使用并查集判断顶点连通性
  - 遍历边集，选择两端不连通的边

- 时间复杂度：

  - 排序阶段：
    $$
    O(|E|\log_2|E|)
    $$

  - 并查集操作：
    $$
    单次O(\log_2|E|)
    $$

  - 总复杂度：
    $$
    O(|E|\log_2|E|)
    $$

- 示例说明：
  $$
  处理边权1的v_0-v_3时，因初始不连通而选中；
  $$

$$
处理边权4的v_3-v_5时因已连通而跳过。
$$



#### 
