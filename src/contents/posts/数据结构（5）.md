---
title: 数据结构-5 #标题
published: 2025-05-31 #发布日期
description: 数据结构学习 #描述
tags: [Markdown, Blogging] #标签
category: 笔记 #分类
draft: false #是否为草稿 （隐藏）
---

# 树与二叉树

## 5.1树的基本概念

### 5.1.1树的定义

- 逻辑结构：树是从树根生长，逐级分支的结构，与自然界中的树相似。由一个根结点出发，通过边连接各个分支结点和叶子结点。
- 结点分类：
  - 分支结点：具有下一级分支的结点（如橙色结点）
  - 叶子结点：没有下一级分支的结点（如绿色结点）
- 特殊形态：
  - 空树：结点数为零的树
  - 非空树：有且仅有一个根结点的树
- 前驱后继关系：
  - 根结点没有前驱
  - 叶子结点没有后继
  - 非根结点有且仅有一个前驱
  - ![img](https://thumbnail0.baidupcs.com/thumbnail/b937a271at33469fd9be76d4ea7309cf?chkbd=0&chkv=0&dp-callid=0&dp-logid=2684680419462137473&expires=8h&fid=1103289404712-250528-957603650638147&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-GqngOxSYbq9CaioaH2a5J49CkXg%3D&size=c1080_u1080&time=1748764800&vuk=1103289404712)
- 数学定义：树是**n(n≥0**)个结点的有限集合，当**n=0**时称为空树。非空树满足：
  - 有且仅有一个根结点
  - 当**n>1**时，其余结点可分为**m(m>0)**个互不相交的子树
- 子树特性：子树之间必须互不相交，每个子树本身又是一棵树

### 5.1.2基本术语

- 祖先结点：从某结点到根结点路径上的所有结点

- 子孙结点：某结点分支下的所有结点

- 双亲结点：结点的直接前驱（如父亲）

- 孩子结点：结点的直接后继（如子女）

- 兄弟结点：同一双亲的孩子结点（如亲兄弟）

- 堂兄弟结点：同一层的非兄弟结点（如堂兄弟）

  > 路径特性：
  >
  > 路径是单向的，只能从上往下
  >
  > 路径长度是路径上经过的边数

- ![img](https://thumbnail0.baidupcs.com/thumbnail/73774069dgf90c3d6264dad97a8361d2?chkbd=0&chkv=0&dp-callid=0&dp-logid=2684680624634903546&expires=8h&fid=1103289404712-250528-363534357884713&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-6j%2BNO4CPQGzdOAJez%2FM6NAYHu1Y%3D&size=c1080_u1080&time=1748764800&vuk=1103289404712)

- 层次/深度：从上往下数，根结点为第1层

- 高度：从下往上数，叶子结点高度为1

- 结点的度：结点拥有的分支数（孩子数）

  - 叶子结点度为0
  - 分支结点度>0

- 树的度：树中所有结点度的最大值

- 树的高度/深度：树的最大层次数

- 有序树和无序树

- ![img](https://thumbnail0.baidupcs.com/thumbnail/3d267bb95rf1361b3b51868ad6483a15?chkbd=0&chkv=0&dp-callid=0&dp-logid=2684680746744793428&expires=8h&fid=1103289404712-250528-328481190933238&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-fYW%2BT3KdTEYFR%2Ft3EjaNfEzFjeI%3D&size=c1080_u1080&time=1748764800&vuk=1103289404712)

- 有序树：子树从左至右有次序，不可互换（如家谱）

- 无序树：子树顺序可互换（如行政区划分）

  > 判断依据：是否需要通过结点位置反映逻辑关系

  树和森林

- ![img](https://thumbnail0.baidupcs.com/thumbnail/58778f255k1bccfb5a49aef88a44e6e3?chkbd=0&chkv=0&dp-callid=0&dp-logid=2684680855397452269&expires=8h&fid=1103289404712-250528-488554252273408&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-ao4NF2Njp14bQy6VZ55fEljoWLk%3D&size=c1080_u1080&time=1748764800&vuk=1103289404712)

- 森林定义：

  ﻿m(m≥0)棵互不相交的树的集合

  > 相互转化：
  >
  > 森林加一个根结点可变为树
  >
  > 树删除根结点可变为森林

  > 特殊形态：允许有空树和空森林

### 5.1.3树的性质

#### 1.结点数=总度数+1

- 核心公式：树的结点总数等于所有结点的度数之和加1，即**结点数=总度数+1**

- 度数定义：结点的度是指该结点拥有的孩子（分支）数量，每个分支对应一个孩子结点

  > 除根节点外，每个结点都通过"天线"（分支）与父节点相连，因此总分支数（总度数）比结点数少1

#### 2.树的度与m叉树的区别

| 属性         | 度为m的树                                              | m叉树                                                  |
| :----------- | :----------------------------------------------------- | :----------------------------------------------------- |
| **定义**     | 树中所有结点度的最大值等于m。                          | 每个结点最多只能有m个孩子。                            |
| **必要条件** | 至少存在一个结点度数为m（即至少有m个孩子）。           | 无（允许所有结点度数都小于m）。                        |
| **结点下限** | 非空树时，至少包含 m+1 个结点（1个根节点 + m个孩子）。 | 允许空树（结点数为0）；非空树时至少1个结点（根节点）。 |
| **灵活性**   | 不灵活：必须存在至少一个度为m的结点。                  | 灵活：允许所有结点度数小于m，甚至可以是空树。          |
| **关键区别** | 强制要求存在度为m的结点。                              | 不强制要求存在度为m的结点。                            |

#### 3.度为m的树第i层至多有m^i-1个结点

- 计算公式：第i层最多有m^{i-1}个结点（i ≥1）
- 推导过程：
  - 第1层（根节点）：﻿**m^0=1**个
  - 第2层：每个父节点最多m个孩子 →**m^1**个
  - 第3层：每个第2层结点最多m个孩子 →**m^2**个
  - 以此类推形成等比数列
- 适用范围：该上限同时适用于度为m的树和m叉树

#### 4.高度为h的m叉树至多有m^h-1个结点

- 最大结点数：
  $$
  \frac{m^h - 1}{m - 1}
  $$
  （等比数列求和结果）

- 推导原理：将各层最大结点数相加（
  $$
  S = 1 + m + m^2 + \cdots + m^{h-1} = \sum_{k=0}^{h-1} m^k）
  $$
  ）

- 等比数列公式：
  $$
  ﻿a + aq + aq^2 + \cdots + aq^{n-1} = \frac{a(1-q^n)}{1-q}﻿
  
  （此处
  
  ﻿a=1﻿
  
  ,
  
  ﻿q=m﻿）
  $$

#### 5.高度为h的m叉树至少有h个结点

- 最小结点数：h个

- 极端情况：形成链式结构，每个非叶结点只有1个孩子

- 度为m的树下限：高度为h、度为m的树至少有
  $$
  ﻿h+m-1﻿
  $$
  个结点（需保证至少一个结点有m个孩子）

#### 6.具有n个结点的m叉树的最小高度

- 计算公式：
  $$
  \lceil \log_m [n(m-1)+1] \rceil
  $$

- 推导过程：

  - 建立不等式：

    ﻿
    $$
    \frac{m^{h-1}-1}{m-1} < n \leq \frac{m^h-1}{m-1}
    $$

  - 变形得：
    $$
    m^{h-1} < n(m-1)+1 \leq m^h
    $$

  - 取对数解出h的范围

- 优化原则：使树尽可能"宽"（每个结点有最多m个孩子）而非"高"

## 5.2二叉树的概念

### 5.2.1 二叉树的定义及其主要特性

#### 1.二叉树的定义

- 定义：二叉树是
  $$
  n(n \geq 0)
  $$
  个结点的有限集合：

  - 空二叉树
    $$
    (﻿n=0﻿)
    $$

  - 由根结点和两个互不相交的左子树、右子树组成（递归定义）

- 特点：

  - 最大分支数：每个结点至多只有两棵子树

  - 有序性：左右子树不能颠倒（区别于度为2的有序树）

    > 递归特性：与树类似，二叉树也是递归定义的数据结构

形态分类：

- 空二叉树
- 只有根结点
- 只有左子树（右子树为空）
- 只有右子树（左子树为空）
- 左右子树均存在

#### 2.几种特殊的二叉树

1.满二叉树

- 定义：高度为h，且含有
  $$
  ﻿2^h-1﻿
  $$
  个结点的二叉树

- 特点：

  - 叶子分布：只有最后一层有叶子结点

  - 结点度数：不存在度为1的结点（只有0或2）

  - 编号规律：按层序从1开始编号时：

    - 结点i的左孩子为2i

    - 右孩子为2i+1

    - 父结点为
      $$
      \lfloor i/2 \rfloor
      $$



2.完全二叉树

- 定义：当且仅当每个结点都与高度为h的满二叉树中编号为
  $$
  ﻿1\sim n﻿
  $$
  的结点一一对应

- 特点：

  - 叶子分布：最后两层可能出现叶子结点

  - 度数限制：最多只有一个度为1的结点

  - 编号继承：继承满二叉树的编号规律

  - 分支判定：当
    $$
    i \leq \lfloor n/2 \rfloor
    $$
    时为分支结点，否则为叶子结点

- 特殊性质：若结点只有一个孩子，则必为左孩子



3.二叉排序树

- 定义：
  - 空二叉树
  - 或满足：
    - 左子树所有结点关键字 < 根结点关键字 < 右子树所有结点关键字
    - 左右子树也是二叉排序树
- 操作特性：
  - 查找：通过比较关键字大小决定搜索路径
  - 插入：新元素插入后仍需保持排序性质
- 应用场景：适合需要频繁查找、排序的场景



4.平衡二叉树

- 定义：树上任一结点的左子树和右子树的深度之差不超过1
- 性能优势：
  - 搜索效率：相比不平衡二叉排序树，搜索路径更短
  - 形态特征：追求"矮胖"形态，限制树的高度增长
- 平衡示例：
  - 平衡树：左右子树高度差≤1
  - 非平衡树：存在高度差>1的情况

#### 3.二叉树的性质

##### 1.二叉树性质

###### 1）非空二叉树结点关系

- ![img](https://thumbnail0.baidupcs.com/thumbnail/7f94114b6rc9192a4de93bfa36f96148?chkbd=0&chkv=0&dp-callid=0&dp-logid=3224247879649619587&expires=8h&fid=1103289404712-250528-197076124827604&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-MsGV6oHnrfmy20EtLSa5gPv3QQY%3D&size=c1080_u1080&time=1748768400&vuk=1103289404712)

- 叶子结点与二分支结点关系：对于非空二叉树，设度为0、1、2的结点数分别为
  $$
  n_0﻿、﻿n_1﻿、﻿n_2﻿，则﻿n_0 = n_2 + 1﻿。
  $$
  这个结论表明叶子结点总是比二分支结点多一个。

- 推导过程：

  - 结点总数
    $$
    ﻿n = n_0 + n_1 + n_2
    $$
    （所有度型结点之和）

  - 根据"树的结点数=总度数+1"性质，可得
    $$
    n = n_1 + 2n_2 + 1
    $$
    （度1结点贡献1个度，度2结点贡献2个度）

  - 联立两式相减即得结论

- 验证方法：可通过具体二叉树实例手动计数验证，如示例中的A1B23DEF4567结构

###### 2）二叉树第i层结点数

- ![img](https://thumbnail0.baidupcs.com/thumbnail/723f3c246g7b62b357f2299467e070cc?chkbd=0&chkv=0&dp-callid=0&dp-logid=3224248018412410105&expires=8h&fid=1103289404712-250528-587800646737802&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-nQwU8LVSRxtHWW%2BEEwf68WMs2%2Fs%3D&size=c1080_u1080&time=1748768400&vuk=1103289404712)

- 最大结点数规律：二叉树第i层最多有
  $$
  ﻿2^{i-1}
  $$
  个结点（i≥1），推广到m叉树则为
  $$
  ﻿m^{i-1}
  $$
  个结点

- 层序示例：

  - $$
    第1层：m^0=1个（根结点）
    $$

  - $$
    第2层：m^1个
    $$

  - $$
    第3层：m^2个
    $$

    

###### 3）高度为h的二叉树结点数 

- ![img](https://thumbnail0.baidupcs.com/thumbnail/3b3cd570ate6feaf02ababc33f00062f?chkbd=0&chkv=0&dp-callid=0&dp-logid=3224248135181728537&expires=8h&fid=1103289404712-250528-810838426162377&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-WCPc8HSANlnwI8VM5oKodMWXq8U%3D&size=c1080_u1080&time=1748768400&vuk=1103289404712)

- 满二叉树情况：高度为h的二叉树最多有
  $$
  2^h - 1
  $$
  个结点（即满二叉树状态）

- m叉树推广：高度为h的m叉树最多有
  $$
  \frac{m^h - 1}{m - 1}
  $$
  个结点，该公式来源于等比数列求和公式
  $$
  a + aq + aq^2 + \cdots + aq^{n-1} = \frac{a(1-q^n)}{1-q}
  $$



##### 2.完全二叉树常考性质

###### 1）完全二叉树的高度

- 两种计算方法：

  - $$
    \lceil \log_2(n+1) \rceil（向上取整）
    $$

  - $$
    \lfloor \log_2n \rfloor + 1（向下取整后加1）
    $$

- 推导逻辑：

  - 上限考虑：高度h的满二叉树结点数
    $$
    2^h-1（n不超过此值）
    $$

  - 下限考虑：前h-1层满二叉树结点数
    $$
    2^{h-1}-1﻿（n必须大于此值）
    $$

  - 通过不等式变形和对数运算得到最终公式

###### 2）完全二叉树的结点数与结点类型数的关系

- ![img](https://thumbnail0.baidupcs.com/thumbnail/f54415447of22fcae5fe65504bec6c58?chkbd=0&chkv=0&dp-callid=0&dp-logid=3224248231416087873&expires=8h&fid=1103289404712-250528-361813626132756&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-h9TgP5wXFDMQ%2BN%2FF80E9QwT5Vcg%3D&size=c1080_u1080&time=1748768400&vuk=1103289404712)

- 关键特性：完全二叉树最多只有1个度为1的结点
  $$
  （即﻿n_1只能是0或1）
  $$
  判断方法：

  - 当总结点数n为偶数时：
    $$
    n_1=1，此时﻿n_0=k，n_2=k-1
    $$

  - 当n为奇数时：
    $$
    n_1=0﻿，此时n_0=k，n_2=k-1
    $$

- 推导依据：结合
  $$
  n_0=n_2+1
  $$
  的基本性质和完全二叉树的特殊结构特性

### 5.2.2二叉树的存储结构

#### 1.顺序存储结构

##### 1. 二叉树的顺序存储

###### 1）完全二叉树的顺序存储

- ![img](https://thumbnail0.baidupcs.com/thumbnail/8466e8b31j18de5be77b5c789ea1e7c9?chkbd=0&chkv=0&dp-callid=0&dp-logid=3934086188838496959&expires=8h&fid=1103289404712-250528-53180364441325&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-8GGC81aTKwJVVHieEEAULlWTemE%3D&size=c1080_u1080&time=1748775600&vuk=1103289404712)

- 存储方式：将完全二叉树中的各个节点按照从上至下、从左至右的顺序依次存储在数组中

- 数据结构定义：

- 初始化：需要将所有元素的isEmpty设置为true，表示初始为空结点

- 存储规则：通常让数组下标与结点编号一致，即t[1]存储1号结点（根结点），t[0]空缺

- 结点关系计算：

  - 左孩子编号：
    $$
    2i
    $$

  - 右孩子编号：
    $$
    2i+1
    $$

  - 父结点编号：
    $$
    \lfloor i/2 \rfloor
    $$

- 判断条件：

  - 判断i是否有左孩子：
    $$
    2i \leq n
    $$

  - 判断i是否有右孩子：
    $$
    2i+1 \leq n
    $$

  - 判断i是否为叶子结点：
    $$
    i > \lfloor n/2 \rfloor
    $$

###### 2）非完全二叉树的顺序存储 

- ![img](https://thumbnail0.baidupcs.com/thumbnail/47c602350s84305baf888b39ff907f33?chkbd=0&chkv=0&dp-callid=0&dp-logid=3934086322891482055&expires=8h&fid=1103289404712-250528-38802362609822&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-B4%2F08M1LGXGTj8JjRD18CuqrxOQ%3D&size=c1080_u1080&time=1748775600&vuk=1103289404712)

- 存储方式：依然按层序将各节点顺序存储，但需要与完全二叉树的结点编号对应

- 关键区别：不能直接通过编号计算结点关系，必须借助isEmpty字段判断

- 判断方法：检查对应位置的isEmpty字段是否为true来判断是否存在子结点

- 空间效率：会产生大量空间浪费，最坏情况下需要
  $$
  2^h-1
  $$
  个存储单元（h为树高）

- 适用性：顺序存储结构只适合存储完全二叉树，实际应用较少

#### 2.链式存储结构

###### 1）二叉链表的构建

- ![img](https://thumbnail0.baidupcs.com/thumbnail/4f917f3c4rb7090fbf1b43c3de68aab8?chkbd=0&chkv=0&dp-callid=0&dp-logid=3934086930377667726&expires=8h&fid=1103289404712-250528-1016794491789446&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-R7V2nd1lPxW4j2W8PkQc8zaQBDc%3D&size=c1080_u1080&time=1748775600&vuk=1103289404712)
- 结点结构：
- 初始化过程：
  - 声明指向根结点的指针，初始为NULL
  - 申请根结点空间，设置数据域和左右指针
  - 递归或迭代方式构建左右子树

###### 2）二叉链表的应用

- ![img](https://thumbnail0.baidupcs.com/thumbnail/55700aa36ua7ed6fadf28dd7cb903788?chkbd=0&chkv=0&dp-callid=0&dp-logid=3934087070210691871&expires=8h&fid=1103289404712-250528-287631456695717&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-2fbsfm4pYgGscyPQyp9V8gg9H1s%3D&size=c1080_u1080&time=1748775600&vuk=1103289404712)
- 查找子结点：直接通过lchild和rchild指针即可快速访问
- 查找父结点：需要从根结点开始遍历查找，时间复杂度较高
- 空指针数量：n个结点的二叉链表共有n+1个空链域（可用于构造线索二叉树）

###### 3）三叉链表

- ![img](https://thumbnail0.baidupcs.com/thumbnail/3a7f1d3d7v59a419bfa660fa0f885650?chkbd=0&chkv=0&dp-callid=0&dp-logid=3934087157289924576&expires=8h&fid=1103289404712-250528-186633084574024&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-lnevjTWcFTCIxqD1Z6%2Bb9dadPLQ%3D&size=c1080_u1080&time=1748775600&vuk=1103289404712)
- 改进结构：在二叉链表基础上增加parent指针指向父结点
- 适用场景：需要频繁查找父结点的应用场景
- 考研重点：考研中主要考察不带parent指针的二叉链表

## 5.3二叉树的遍历和线索二叉树

### 5.3.1二叉树的遍历

- 基本概念：按照某种规定的次序把所有节点都访问一遍的操作
- 线性结构：从头到尾或从尾到头的简单遍历规则
- 树形结构：利用分层特性产生更复杂的遍历规则
- 层次遍历：基于树的分层特性，按层次访问节点的遍历方式



###### 二叉树的递归特性

- 组成特性：
  - 要么是空二叉树
  - 要么由"根节点+左子树+右子树"组成（左右子树可能为空）
- 遍历基础：基于递归特性制定遍历规则

#### 1.先序遍历

- 顺序：根→左→右
- 别名：先根遍历
- 递归规则：对子树同样采用先序遍历

- 递归实现：

```c
void PreOrder(BiTree T){
    if(T != NULL){
        visit(T);               // 访问根节点
        PreOrder(T->lchild);    // 递归遍历左子树
        PreOrder(T->rchild);    // 递归遍历右子树
    }
}
```

- 结构体定义：

```c
typedef struct BiTNode{
    ElemType data;
    struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
```

- 注意事项：
  - 空树直接返回
  - visit()函数可自定义操作（如打印节点值）
  - 中序/后序遍历代码结构类似，仅调整访问顺序



###### 空间复杂度分析

- 复杂度计算：递归算法的空间复杂度为
  $$
  O(h+1)
  $$
  ，其中h为二叉树高度

- 加1原因：叶子结点下的空结点也需要压栈处理

- 简化表示：通常舍去常数项，记为O(h)的空间复杂度



递归特征：每个结点都会被访问三次，对应不同的处理阶段



#### 2.中序遍历

- 顺序：左→根→右
- 别名：中根遍历
- 代码结构：中序遍历采用递归实现，核心代码为：

```c
void InOrder(BiTree T){
    if(T != NULL){
        InOrder(T->lchild);  // 递归遍历左子树
        visit(T);            // 访问根结点
        InOrder(T->rchild);  // 递归遍历右子树
    }
}
```

- 访问顺序：遵循"左-根-右"的访问顺序，只需将visit函数放在两次递归调用之间即可实现
- 数据结构：二叉树结点定义为：

```c
typedef struct BiTNode{
    ElemType data;
    struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
```

- 访问时机：第二次经过节点时才进行访问
- 典型特征：
  - 左子树→根节点→右子树的访问顺序
  - 第一个被访问的总是最左端的非空节点

#### 3.后序遍历

- 顺序：左→右→根
- 别名：后根遍历
- 关键特征：第三次路过节点时才进行访问
- 行走规律：
  - 必须完整遍历完左右子树后才能访问根节点
  - 第一个被访问的总是最左端的叶子节点

#### 4.层次遍历

- 遍历顺序：按照从上到下、从左到右的顺序逐层访问节点
- 辅助工具：需要设置一个辅助队列来实现层序遍历
- 算法步骤：
  - 初始化队列：创建一个空队列
  - 根节点入队：将二叉树的根节点放入队列
  - 循环处理：
    - 队头节点出队并访问
    - 将该节点的左孩子（如果存在）入队
    - 将该节点的右孩子（如果存在）入队
  - 终止条件：当队列为空时遍历结束

##### 2. 代码实现

- ![img](https://thumbnail0.baidupcs.com/thumbnail/4b0feabaaof6d1a0262da0d949dca8f1?chkbd=0&chkv=0&dp-callid=0&dp-logid=28906192301507494&expires=8h&fid=1103289404712-250528-281239732787318&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-OOwuQmHs3Op018pgGkK65VQaq48%3D&size=c1080_u1080&time=1748779200&vuk=1103289404712)
- 数据结构：
  - 使用链式队列而非顺序队列，因为难以预估节点数量
  - 队列中存储的是节点指针而非节点本身，节省空间
- 实现细节：
  - 访问节点时可自定义操作，如打印节点值
  - 左右孩子入队顺序固定：先左后右
  - 叶子节点处理时不会产生新入队操作

#### 5.由遍历序列构造二叉树

必须通过中序序列划分左右子树

前序/后序/层序用于确定各层根结点

> "无中序不唯一，有中序可递归"

## 5.4树、森林

### 5.4.1树的存储结构

#### 1.双亲表示法

- 核心思想: 利用每个非根结点有且仅有一个双亲的特性

- 存储方式: 数组顺序存储结点，每个结点保存数据和双亲下标（根结点双亲为-1）

- 双亲表示法的定义 

  - ![img](https://thumbnail0.baidupcs.com/thumbnail/7eb21df08h856429356416a9557df354?chkbd=0&chkv=0&dp-callid=0&dp-logid=310379586266486337&expires=8h&fid=1103289404712-250528-1013345993530052&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Z%2B9C2nDh6CfU0BAjmkPIibZ9NvU%3D&size=c1080_u1080&time=1748782800&vuk=1103289404712)
  - 结点结构: 包含data数据域和parent双亲位置域
  - 类型定义: 使用数组nodes[MAX_TREE_SIZE]存储结点，记录结点数n
  - 示例说明: 如图中4号结点的父节点是1号结点，10号结点的父节点是4号

- 双亲表示法存储森林 

  - ![img](https://thumbnail0.baidupcs.com/thumbnail/d09853b64te9361a752c96f992414c8e?chkbd=0&chkv=0&dp-callid=0&dp-logid=310379080435350924&expires=8h&fid=1103289404712-250528-682272682786493&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-IJYz75ivqAZvCFEsff8pfeKu7A4%3D&size=c1080_u1080&time=1748782800&vuk=1103289404712)

  - 森林定义:
    $$
    m(m\geq0)
    $$
    棵互不相交的树的集合

  - 实现方式: 将各树根结点的parent设为-1，其他结点正常记录双亲下标

- 双亲表示法的优缺点 

  - ![img](https://thumbnail0.baidupcs.com/thumbnail/61b268a99r8afafae088035557112075?chkbd=0&chkv=0&dp-callid=0&dp-logid=310379673210583398&expires=8h&fid=1103289404712-250528-369230328346907&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-6ciIoPmzsk2DLdk%2FWUZsf3Uq%2Bxo%3D&size=c1080_u1080&time=1748782800&vuk=1103289404712)
  - 优点: 找父节点高效（直接访问parent域）
  - 缺点: 找孩子需遍历整个数组
  - 适用场景: "找父亲"多"找孩子"少的应用（如并查集）

#### 2.孩子表示法

###### 1）孩子表示法的定义

- ![img](https://thumbnail0.baidupcs.com/thumbnail/272dff328m060a09e0f99d898e5c0ff7?chkbd=0&chkv=0&dp-callid=0&dp-logid=310379164558832995&expires=8h&fid=1103289404712-250528-1093332418245029&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-DEobrvygzI6i0b7W2zZGPWAImLk%3D&size=c1080_u1080&time=1748782800&vuk=1103289404712)
- 混合存储: 顺序存储结点+链式存储孩子关系
- 结点结构: 数组元素包含data和*firstChild指针，指向孩子链表
- 链表结点: 保存child（孩子下标）和*next指针

###### 2）孩子表示法存储森林

- ![img](https://thumbnail0.baidupcs.com/thumbnail/ab4983965tf4d71699d00333f92be8c7?chkbd=0&chkv=0&dp-callid=0&dp-logid=310379782732138766&expires=8h&fid=1103289404712-250528-310969041589471&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-edNvQZKglEg5fftDOjNTYFQxJkQ%3D&size=c1080_u1080&time=1748782800&vuk=1103289404712)
- 实现方式: 各树根结点的firstChild指向其孩子链表，无孩子的设为NULL
- 特殊处理: 需在结构体中记录多个根的位置

###### 3）孩子表示法的优缺点

- ![img](https://thumbnail0.baidupcs.com/thumbnail/a1babfaa3of2afc734a81c58fea46367?chkbd=0&chkv=0&dp-callid=0&dp-logid=310379304648713942&expires=8h&fid=1103289404712-250528-990222286074534&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-Ge%2Fj6871R4FU2tKGegrQ40nDECw%3D&size=c1080_u1080&time=1748782800&vuk=1103289404712)
- 优点: 找孩子高效（通过孩子链表）
- 缺点: 找父节点需遍历所有链表
- 应用场景: 服务流程树等"找孩子"多的场景

#### 3.孩子兄弟表示法

###### 1）孩子兄弟表示法的定义

- ![img](https://thumbnail0.baidupcs.com/thumbnail/59a3c1e5ei4c305f9b5c01fca36536ce?chkbd=0&chkv=0&dp-callid=0&dp-logid=310379414325282625&expires=8h&fid=1103289404712-250528-1080845776819500&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-A%2BTk7FkSeXzRUtsVhi2ATdTY%2BL8%3D&size=c1080_u1080&time=1748782800&vuk=1103289404712)
- 链式结构: 类似二叉链表，含data、*firstchild和*nextsibling指针
- 指针含义: 左指针指向第一个孩子，右指针指向右兄弟
- 存储视角: 物理形态与二叉树类似，但逻辑解释不同

###### 2）孩子兄弟表示法存储森林

- ![img](https://thumbnail0.baidupcs.com/thumbnail/237ab0098gee3974060c471c4895c09e?chkbd=0&chkv=0&dp-callid=0&dp-logid=310378713836201113&expires=8h&fid=1103289404712-250528-845417723808161&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-7UXCmwHoQbeFR4t7WnrYlE4q3YM%3D&size=c1080_u1080&time=1748782800&vuk=1103289404712)
- 关键处理: 将各树根结点视为平级兄弟关系
- 示例说明: 三棵树根B、C、D通过右指针连接，B的左指针连E，C的左指针连G等

### 5.4.2 树、森林与二叉树的转换

#### 1.树转换为二叉树

采用孩子兄弟表示法存储树，按层序处理节点： 

1. 画根结点; 
2. 将孩子结点用右指针串成链（“冰糖葫芦”）;
3. 第一个孩子挂左指针

#### 2.森林转换为二叉树

多棵树根结点视为兄弟，右指针串联： 

1. 所有根结点右链化; 
2. 按森林层序处理（整体层次遍历）

#### 3.二叉树转换为森林

逆向拆解右链： 

1. 根结点左孩子为首个子结点; 
2. 右链结点为同级兄弟; 
3. 森林需拆分根右链为多棵树

### 5.4.3 树和森林的遍历

#### 1.树的遍历

##### 1、树的先根遍历 ﻿

- ![img](https://thumbnail0.baidupcs.com/thumbnail/2960041bbse3fd0b15a0d6d062c4c9f5?chkbd=0&chkv=0&dp-callid=0&dp-logid=412473210207471266&expires=8h&fid=1103289404712-250528-28833300796188&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-CK0oM%2B6%2BjjF10wfwViDKPzC94zU%3D&size=c1080_u1080&time=1748782800&vuk=1103289404712)
- 遍历规则：
  - 若树非空，先访问根结点
  - 再依次对每棵子树进行先根遍历
- 算法实现：
- 示例分析：对示例树的先根遍历序列为A→B→E→K→F→C→G→D→H→I→J
- 与二叉树关系：树的先根遍历序列与其对应二叉树的先序遍历序列相同

##### 2、树的后根遍历

- ![img](https://thumbnail0.baidupcs.com/thumbnail/58a21d9a2r9f5967b9b0d63b85a398c8?chkbd=0&chkv=0&dp-callid=0&dp-logid=412473309609967446&expires=8h&fid=1103289404712-250528-152182995565370&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-bZM11kRGZsHyuRcHbA5hGTKE6XA%3D&size=c1080_u1080&time=1748782800&vuk=1103289404712)
- 遍历规则：
  - 若树非空，先依次对每棵子树进行后根遍历
  - 最后访问根结点
- 算法实现：
- 示例分析：对示例树的后根遍历序列为K→E→F→B→G→C→H→I→J→D→A
- 与二叉树关系：树的后根遍历序列与其对应二叉树的中序遍历序列相同
- 遍历特性：属于深度优先遍历方式

##### 3、树的层次遍历 

###### 1. 层次遍历的实现思路 ﻿

- 实现方法：
  - 使用辅助队列
  - 根节点入队
  - 循环执行：
    - 队头元素出队并访问
    - 将该元素的孩子依次入队
  - 直到队列为空
- 示例过程：A→B→C→D→E→F→G→H→I→J→K

###### 2. 层次遍历的特性

- 广度优先：层次遍历也称为广度优先遍历，特点是横向探索节点
- 应用场景：适合需要按层级处理节点的场景

###### 3. 深度优先遍历与广度优先遍历的对比 

- 深度优先：包括先根和后根遍历，优先往深处探索
- 广度优先：即层次遍历，优先横向探索
- 选择依据：根据具体需求选择遍历方式

#### 2.森林的遍历

##### 1. 森林的先序遍历

- 遍历规则：
  - 访问森林中第一棵树的根结点
  - 先序遍历第一棵树的子树森林
  - 先序遍历剩余树构成的森林
- 等效方法：
  - 效果等同于依次对各树进行先根遍历
  - 序列与对应二叉树的先序遍历序列相同

##### 2. 森林的中序遍历

- ![img](https://thumbnail0.baidupcs.com/thumbnail/cb9e0af3eq3963ab4e50498c68ee48b1?chkbd=0&chkv=0&dp-callid=0&dp-logid=412473454240728956&expires=8h&fid=1103289404712-250528-700811081064176&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-xQoiBsgQ4hcU3nZItU5uMt%2BLahg%3D&size=c1080_u1080&time=1748782800&vuk=1103289404712)
- 遍历规则：
  - 中序遍历第一棵树的子树森林
  - 访问第一棵树的根结点
  - 中序遍历剩余树构成的森林
- 等效方法：
  - 效果等同于依次对各树进行后根遍历
  - 序列与对应二叉树的中序遍历序列相同

## 5.5树与二叉树的应用

### 5.5.1 哈夫曼树和哈夫曼编码

- 节点的权: 节点权值表示某种现实含义的数值，如节点的重要性等。
- 节点的带权路径长度: 从树的根节点到指定节点的路径长度（经过的边数）与该节点权值的乘积。
- 树的带权路径长度(WPL): 树中所有叶子节点的带权路径长度之和。

#### 1.哈夫曼树的定义

哈夫曼树（最优二叉树）: 在含有n个带权叶结点的二叉树中，带权路径长度(WPL)最小的二叉树。

#### 2.哈夫曼树的构造

- 构造算法:
  - 步骤1: 将n个结点分别作为n棵仅含一个结点的二叉树，构成森林F。
  - 步骤2: 构造一个新结点，从F中选取两棵根结点权值最小的树作为新结点的左、右子树，新结点的权值置为左、右子树根结点权值之和。
  - 步骤3: 从F中删除选出的两棵树，将新树加入F中。
  - 步骤4: 重复步骤2和3，直至F中只剩下一棵树为止。
- 性质:
  - 初始结点最终都成为叶子结点。
  - 权值越小的节点到根节点的路径长度越长。
  - 总共需要合并n-1次，结点总数为2n-1。
  - 哈夫曼树中不存在度为1的节点。
  - 哈夫曼树不唯一，但WPL必然都是最小值。

#### 3.哈夫曼编码

- 应用背景: 如电报传输中的二进制编码。
- 固定长度编码: 每个字符用相等长度的二进制位表示，如ASCII码。
- 可变长度编码: 允许对不同字符用不等长的二进制位表示。
- 前缀编码: 若没有一个编码是另一个编码的前缀，则称这样的编码为前缀编码，哈夫曼编码就是一种前缀编码。
- 构造方法:
  - 字符集中的每个字符作为一个叶子结点。
  - 各个字符出现的频度作为结点的权值。
  - 根据哈夫曼树构造方法构造哈夫曼树。
  - 从根节点出发，向左的路径看作二进制0，向右的路径看作二进制1，得到字符的哈夫曼编码。
- 优点: 可用于数据压缩，减少传输或存储的数据量。

