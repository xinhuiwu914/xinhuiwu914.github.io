---
title: 数据结构-3 #标题
published: 2025-05-20 #发布日期
description: 数据结构学习 #描述
tags: [Markdown, Blogging] #标签
category: 笔记 #分类
draft: false #是否为草稿 （隐藏）
---
# 栈、队列和数组

## 3.1栈

### 3.1.1栈的基本概念

#### 1.栈的定义

只允许在一端插入或删除的**线性表**

> 栈顶（top）:允许插入或删除的一端
>
> 栈底（bottom）：固定的，不允许插入或删除的一端

#### 2.栈的基本操作

InitStack(&S):初始化一个空栈 S。

StackEmpty(S):判断一个栈是否为空，若栈S为空则返回 true，否则返回 false。

Push(&S,x):入栈，若栈S未满，则将x加入使之成为新栈顶。

Pop(&S，&x):出栈，若栈s非空，则弹出栈顶元素，并用x返回。

GetTop(S,&x):读栈顶元素，但不出栈，若S非空，则用x返回顶元素。

DestroyStack(&S):销毁栈，并释放栈S占用的存储空间(“&”表示引用调用)。


> 当n个不同元素入栈时，出栈元素不同排列的个数为
> $$
> 
> \frac{1}{n+1} C_{2n}^{n}
> $$
> 也称卡特兰数

### 3.1.2栈的顺序存储结构

#### 1.顺序栈的实现

```c
#define MaxSize 50	//定义栈中元素的最大个数
typedef struct{
    Elemtype data[MaxSize];	//存放栈中元素
    int top;	//栈顶指针
}SqStack;
```

> 栈顶指针：S.top,初始时设置S.top=-1;栈顶元素：S.data[S.top]
>
> 入栈操作：栈不满时，栈顶指针先加 1，再送值到栈顶。
>
> 出栈操作：栈非空时，先取栈顶元素，再将栈顶指针减1。
>
> 栈空条件:S.top==-1;
>
> 栈满条件:s.top==MaxSize-1;
>
> 栈长:s.top+1。



> 另一种常见的方式是:
>
> 初始设置栈顶指针s.top=0;
>
> 入时先将值送到栈顶，栈顶指针再加 1;
>
> 出栈时，栈顶指针先减1，再取栈顶元素;
>
> 栈空条件是s.top==0;
>
> 栈满条件是S.top==MaxSize。

#### 2.顺序栈的基本操作

（1）初始化

```c
void InitStack(SqStack &S){
    S.top=-1;	//初始化栈顶指针
}
```

（2）判栈空

```c
bool StackEmpty(SqStack S){
    if(S.top==-1)	//栈空
        return true;
    else			//不空
        return false;
}
```

（3）入栈

```c
bool Push(SqStack &S.ElemType x){
    if(S.top==MaxSize-1)	//栈满，报错
        return false;
	S.data[++S.top]=x;	//指针先加 1，再入栈
	return true;
}
```

（4）出栈

```c
bool Pop(SqStack &S,ElemType &x){
    if(S.top==-1)	//栈空，报错
		return false;
    x=S.data[s.top--];	//先出栈，指针再减1
    return true;
}
```

（5）读栈顶元素

```c
bool GetTop(Sqstack S,ElemType &x){
    if(S.top==-1)	//栈空，报错
		return false;
    x=S.data[S.top];	//x记录栈顶元素
    return true;
}
```

**另一种方式**

（1）初始化

```c
void InitStack(SqStack &S){
    S.top=0;	//初始化栈顶指针--0
}
```

（2）判栈空

```c
bool StackEmpty(SqStack S){
    if(S.top==0)	//栈空
        return true;
    else			//不空
        return false;
}
```

（3）入栈

```c
bool Push(SqStack &S.ElemType x){
    if(S.top==MaxSize)	//栈满，报错
        return false;
	S.data[S.top++]=x;	//指针先加 1，再入栈
	return true;
}
```

（4）出栈

```c
bool Pop(SqStack &S,ElemType &x){
    if(S.top==0)	//栈空，报错
		return false;
    x=S.data[--S.top];	//先出栈，指针再减1
    return true;
}
```

（5）读栈顶元素

```c
bool GetTop(Sqstack S,ElemType &x){
    if(S.top==0)	//栈空，报错
		return false;
    x=S.data[S.top];	//x记录栈顶元素
    return true;
}
```

#### 共享栈

```c
// 定义栈元素最大个数
#define Maxsize 10  

// 静态数组存放栈中元素
typedef struct {
    Elemtype data[Maxsize];  
    
    // 0号栈栈顶指针
    int top0;  
    
    // 1号栈栈顶指针
    int top1;  
} ShStack;

// 初始化栈
void InitStack(ShStack &S) {
    
    // 初始化栈指针
    S.top0 = -1; 
    
    S.top1 = Maxsize;
}
```

>  栈满的条件：top0 + 1 == top1
>
> top0=-1:0号栈为空
>
> top1=MaxSize:1号栈为空
>
> 当0号栈入栈时 top0 先加 1再赋值，1号栈入栈时 top1 先减1再赋值;出栈时则刚好相反。
>
> 存取数据时间复杂度：O（1）

#### 3.1.3栈的链式存储结构

```c
typedef struct Linknode{
    ElemType data;	//数据域
	struct Linknode *next;	//指针域
	}LiStack;	//栈类型定义
```

## 3.2队列

### 3.2.1队列的基本概念

#### 1.队列的定义

一端进行插入，另一端进行删除。也是**线性表**

> 插入元素：入队/进队
>
> 删除元素：出队/离队
>
> **先进先出**：最早排队的最先离队
>
> 队头（Front）：允许删除的一端，也称队首
>
> 队尾（Rear）：允许插入的一端
>
> 空队列：不含任何元素的空表

#### 队列常见的基本操作

InitQueue(&Q):初始化队列，构造一个空队列 Q。

QueueEmpty(Q):判队列空，若队列Q为空返回 true，否则返回 false。

EnQueue(&Q,x):入队，若队列只未满，将x加入，使之成为新的队尾。

DeQueue(&Q,&x):出队，若队列Q非空，删除队首元素，并用x返回。

GetHead(Q,&x):读队首元素，若队列Q非空，则将队首元素赋值给x。


### 3.2.2队列的顺序存储结构

#### 1.队列的顺序存储

队列的顺序存储类型

```c
#define MaxSize 50    //定义队列中元素的最大个数
	typedef struct{
    ElemType data[MaxSize];    //用数组存放队列元素
    int front,rear;    //队首指针和队尾指针
}SqQueue;
```

>初始时:Q.front=Q.rear=0。
>入队操作:队不满时，先送值到队尾元素，再将队尾指针加1。
>出队操作:队不空时，先取队首元素值，再将队首指针加1。

判断队列是否为空

```c
// 判断队列是否为空
bool IsQueueEmpty(Queue Q) {
    // 队空条件
    if (Q.rear == Q.front) 
        return true;
    else
        return false;
}
```

> 队空条件：Q.rear == Q.front
>
> 不能用Q.rear==MaxSize来判断队满，若队列仅有一个元素慧出现“假溢出”（上溢出）

#### 2.队列循环

初始时:Q.front=Q.rear=0。

队首指针进1:Q.front=(Q.front+1)%MaxSize。

队尾指针进1:Q.rear=(Q.rear+1)%MaxSize。

队列长度:(Q.rear+MaxSize-Q.front)%Maxsize。

出入队时:指针都按顺时针方向进1。



**区分队空/队满的三种处理方式：**

1. 队满条件:(Q.rear+1)%MaxSize==Q.front。
   队空条件:Q.front==Q.rear。
   队列中元素的个数:(Q.rear-Q.front+Maxsize)%Maxsize

2. 类型中增设 size 数据成员，表示元素个数。

   若删除成功，则 size减 1，若插入成功,则 size 加 1，

   队空时 Q.size==0;队满时 Q.size==Maxsize，

   两种情况都有Q.front==Q.rear。

3. 类型中增设 tag 数据成员，以区分是队满还是队空。

   删除成功置 tag=0，若导致Q.front==Q.rear，则为队空;

   插入成功置 tag=1，若导致 Q.front==Q.rear，则为队满。

#### 3.循环队列的操作

(1) 初始化 

```c
void InitQueue(SqQueue &Q){
    Q.rear = Q.front = 0;    //初始化队首、队尾指针
}
```

(2) 判队空

```c
bool isEmpty(SqQueue Q){
    if(Q.rear == Q.front)    //队空条件
        return true;
    else
        return false;
}
```

(3) 入队 

```c
bool EnQueue(SqQueue &Q, ElemType x){
    if((Q.rear + 1) % MaxSize == Q.front)    //队满则报错
        return false;
    Q.data[Q.rear] = x;
    Q.rear = (Q.rear + 1) % MaxSize;    //队尾指针加1取模
    return true;
}
```

(4) 出队 

```c
bool DeQueue(SqQueue &Q, ElemType &x){
    if(Q.rear == Q.front)    //队空则报错
        return false;
    x = Q.data[Q.front];
    Q.front = (Q.front + 1) % MaxSize;    //队首指针加1取模
    return true;
}
```

(5)查

```c
//获得队头元素的值，用X返回
bool GetHead (SqQueue  Q, ElemType &x){
	if (Q.rear==(Q.frort) 
		return false;	 //队空则报错
	x=Q.data [Q.front];
	return faseprue,
}
```

> 初始化时：rear=front =0
>
> 队空条件：Q.rear=Q.front
>
> 队列已满的条件：队尾指针的再下一个位置就是队头，即((Q.rear+1)%MaxSize==Q.front
>
> 队列元素个数=(rear+MaxSize-front) %MaxSize

### 3.2.3 队列的链式存储结构

#### 1.队列的链式存储

```c
typedef struct LinkNode{	//链式队列结点
    ElemType data;
	struct LinkNode *next;
}LinkNode ;
typedef struct{		//链式队列
	LinkNode *front,*rear;		//队列的队头和队尾指针
}LinkQueue;
```

> 不带头结点时，当Q.front==NULL且Q.rear==NULL 时，链式队列为空。

#### 2.链式队列的基本操作

 (1) 初始化 

```c
void InitQueue(LinkQueue &Q) {        // 初始化带头结点的链式队列
    Q.front = Q.rear = (LinkNode*)malloc(sizeof(LinkNode));  // 建立头结点
    Q.front->next = NULL;      // 初始为空
}
```

 (2) 判队空 

```c
bool IsEmpty(LinkQueue Q) {
    if(Q.front == Q.rear)       // 判定条件
        return true;
    else
        return false;
}
```

 (3) 入队 (带头节点)

```c
void EnQueue(LinkQueue &Q, ElemType x) {
    LinkNode *s = (LinkNode *)malloc(sizeof(LinkNode));  // 创建新结点
    s->data = x;
    s->next = NULL;
    Q.rear->next = s;                        // 插入链尾
    Q.rear = s;                              // 修改尾指针
}
```

 (3) 入队 (不带头节点)

```c
void EnQueue(LinkNode *s, ElemType x)
{
    LinkNode *s = (LinkNode *)malloc(sizeof(LinkNode));
    s->data = x;
    s->next = NULL;

    if (Q.front == NULL) {  // 在空队列中插入第一个元素
        Q.front = s; 	//修改队头队尾指针
        Q.rear = s;		//不带头结点的队列，第一个元素入队需特别处理
    } else {
        Q.rear->next = s;   // 新结点插入到rear指针之后
        Q.rear = s;		//修改rear指针
    }
}
```

(4) 出队  (带头节点)

```c
bool DeQueue(LinkQueue &Q, ElemType &x) {
    if(Q.front == Q.rear)
        return false;                        // 空队
    LinkNode *p = Q.front->next;             // 取首元结点
    x = p->data;
    Q.front->next = p->next;
    if(Q.rear == p)                          // 若删除最后一个结点
        Q.rear = Q.front;                   // 重置队尾指针
    free(p);
    return true;
}
```

(4) 出队  (不带头节点)
```c
bool DeQueue(LinkQueue &Q, ElemType &x) {
    if (Q.front == NULL)               // 空队列判断
        return false;
	LinkNode *p = Q.front;            // 临时指针指向队首结点
	x = p->data;                      // 用变量X返回队头元素

	Q.front = p->next;                // 更新队首指针

	if (Q.rear == p) {                // 若删除的是最后一个结点
    	Q.front = NULL;               // 队首指针置空
    	Q.rear = NULL;                // 队尾指针置空（队列空状态）
}

	free(p);                          // 释放原队首结点内存
	return true;                      // 出队成功
}
```
(5)链式队列长度

```c
typedef struct LinkNode{
    ElemType data;
	struct LinkNode *next;
}LinkNode;
typedef struct{
	LinkNode *front, *rear; //int langtn 
}Link Quene; 
```

> 时间复杂度O（n）

