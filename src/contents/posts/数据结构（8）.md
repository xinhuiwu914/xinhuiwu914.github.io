---
title: 数据结构-8 #标题
published: 2025-06-06 #发布日期
description: 数据结构学习 #描述
tags: [Markdown, Blogging] #标签
category: 笔记 #分类
draft: false #是否为草稿 （隐藏）
---

# 排序

## 8.1 排序的基本概念

### 8.1.1 排序的定义

#### 1. 排序

- 定义：将数据元素按关键字递增或递减的顺序重新排列的过程

- 输入输出：

  - 输入：
    $$
    n个记录R_{1},R_{2},...,R_{n}及其对应关键字k_{1},k_{2},...,k_{n}
    $$
    
  - 输出：重排后的序列
    $$
    R_{1}^{\prime},R_{2}^{\prime},...,R_{n}^{\prime}，满足k_{1}^{\prime} \leqslant k_{2}^{\prime} \leqslant ... \leqslant k_{n}^{\prime}（或递减）
    $$

#### 2. 排序算法的评价指标 

基础指标：

- 时间复杂度：算法执行所需时间
- 空间复杂度：算法执行所需额外空间

##### 1）算法的稳定性

定义：若排序前R_{i}在R_{j}前面且key_{i}=key_{j}，排序后R_{i}仍在R_{j}前面，则称算法稳定

示例：紫色3和红色3的相对位置是否改变

应用选择：

- 无稳定性要求或关键字唯一时，可不考虑稳定性
- 稳定性不是绝对优劣标准，需结合实际需求



#### 3. 排序算法的分类

##### 1）内部排序

- 特点：所有待排序数据可一次性装入内存
- 关注重点：时间复杂度和空间复杂度
- 处理速度：内存访问速度快（约60GB/s）

##### 2）外部排序

- 特点：数据量过大无法全部装入内存（如超过8GB的文件）
- 关键指标：读写磁盘次数（机械硬盘约100MB/s，比内存慢600倍）
- 处理策略：分块处理，重点关注减少磁盘I/O



## 8.2 插入排序

### 8.2.1直接插入排序

#### 1. 算法思想

##### 1）插入排序的定义

- 核心思想：每次将一个待排序的记录按其关键字大小插入到前面已排好序的子序列中，直到全部记录插入完成。
- 处理方式：从第二个元素开始处理，认为当前元素之前的子序列已经有序。

##### 2）插入排序的过程演示

- 具体步骤：
  - 初始处理：从第二个元素38开始，与前面已排序的49比较，49>38，将49后移，38插入到49前
  - 后续处理：
    - 65比49大，保持原位
    - 97比65大，保持原位
    - 76比97小，97后移；76>65，插入到65后
    - 13比前面所有元素小，全部元素后移，13插入首位
    - 27插入到13和38之间
    - 第二个49插入时，只移动比它大的元素，保持算法稳定性



#### 2. 算法实现

##### 1）直接插入排序

- 代码结构：
  - 外层循环：for(i=1; i<n; i++) 遍历待排序元素
  - 条件判断：if(A[i]<A[i-1]) 只有当前元素小于前驱时才处理
  - 内层循环：for(j=i-1; j>=0 && A[j]>temp; --j) 检查并移动已排序元素
- 关键操作：
  - 使用temp暂存当前元素值
  - 所有大于temp的元素都向后挪位
  - 最后将temp复制到正确插入位置
- 特点：需要每次循环判断j>=0，逻辑清晰但效率略低

- 改进点：

  - 数组从下标1开始存储，A[0]作为哨兵
  - 将当前元素复制到哨兵位置A[0]=A[i]
  - 内层循环简化为for(j=i-1; A[0]<A[j]; --j)

- 优势：

  - 省去j>=0的判断，循环效率更高
  - 当j减到0时自动停止（A[0]==A[0]）

- 实现细节：

  - 外层循环从i=2开始

  - 最终插入位置为A[j+1]=A[0]

    > 注意事项：虽然效率略有提升，但逻辑不如普通实现直观，考试中可自由选择实现方式



#### 3. 算法效率分析

##### 1）直接插入排序（带哨兵）的空间复杂度

- 辅助空间：仅需定义循环变量i,j和使用A[0]作为哨兵位，所有辅助变量均为常数级存储
- 数量级分析：空间消耗与问题规模n无关，始终固定为O(1)量级



##### 2）直接插入排序（带哨兵）的时间复杂度

- 主要开销：来自关键字对比（if判断）和元素移动（for循环）两个部分
- 处理趟数：对于n个元素需要进行n-1趟处理，每趟处理一个元素



##### 3）直接插入排序（带哨兵）的最好情况

- 前提条件：原始序列已有序排列
- 操作特点：每趟只需1次关键字对比（A[i]﻿判断），无需移动元素
- 时间复杂度：总对比次数为n-1次，达到O(n)线性复杂度

##### 4）直接插入排序（带哨兵）的最坏情况

- 前提条件：原始序列完全逆序排列
- 操作特点：每趟需对比之前所有元素（如第n趟需对比n-1次），且每次对比后都要移动元素
- 时间复杂度：关键字对比和移动次数总和达到﻿O(n^2)平方复杂度

##### 5）直接插入排序（带哨兵）的平均时间复杂度和算法稳定性

- 平均复杂度：课本采用(最好+最坏)/2的计算方式，结果为O(n^2)
- 稳定性：具有稳定性，当遇到相等元素时不改变原有相对顺序



### 8.2.3 希尔排序

#### 1. 希尔排序的含义

##### 1）插入排序

- 优化基础: 希尔排序是基于插入排序的优化算法，当数据原本有序或基本有序时，插入排序效率较高。
- 效率表现: 如序列[10,20,30,40,50,60,70,80]原本有序时，插入排序只需比较n-1次无需移动元素；基本有序序列[20,30,10,50,60,40,70,80]也只需少量移动。



##### 2）希尔排序思想﻿

- 核心策略: 通过增量d将表分割为特殊子表L[i, i+d, i+2d,...]，先使子表局部有序，再逐步缩小增量直至全局有序。

- 实现步骤:

  - $$
    初始增量d_1=n/2n为元素总数）
    $$

  - 对每个子表进行直接插入排序

  - $$
    增量折半d_{k+1}=d_k/2重复步骤
    $$

  - 最终d=1时整体排序



#### 2. 希尔排序的算法实现

##### 1）希尔排序算法概述

- 基本思想：将待排序表分割成若干形如[i,i+d,i+2d,...,i+kd]的"特殊"子表，对各个子表分别进行直接插入排序

- 增量变化：初始增量d=n/2，每趟处理后缩小增量为d=d/2，直到d=1为止

- 代码特点：

  - 使用﻿A[0]

    作为暂存单元（非哨兵）

  - 当j<=0时表示插入位置已到

  - 采用轮流切换处理不同子表的方式



##### 2）希尔排序的第一趟处理

- 初始设置：

  - 示例序列：49 38 65 97 76 13 27 49

  - $$
    初始增量d_1=4元素个数8/2）
    $$

  - 处理起点i=d+1=5（从子表第二个元素开始）

- 处理过程：

  - 第一子表（49,76）：76>49不移动
  - 第二子表（38,13）：13<38，将13暂存后前移
  - 第三子表（65,27）：27<65，处理方式类似
  - 第四子表（97,49）：49<97，进行插入排序



##### 3）希尔排序的第二趟处理

- 增量变化：
  $$
  d_2=d_1/2=2
  $$

- 处理特点：

  - 子表数量减少为2个
  - 每个子表元素增多（如第一子表：49,27,76,49）
  - 处理顺序仍为轮流切换子表

- 关键操作：

  - 27<49时，将49后移，27插入
  - 38<49时，进行元素移动和插入



##### 4）希尔排序的第三趟处理及最终排序结果

- 最终处理：

  
  $$
  d_3=1时退化为直接插入排序
  $$

- 结果验证：

  - 最终序列：13 27 38 49 49 65 76 97
  - 保证整体有序性

- 实现变体：

  - 可改为连续处理同一子表所有元素后再切换
  - 两种实现方式时间复杂度相同



##### 5）希尔排序代码实现的逻辑分析

- 插入过程：

  - 暂存当前元素A[0]=A[i]

  - $$
    后移元素时步长为d（A[j+d]=A[j]）
    $$

  - 最终插入位置为

    ﻿j+d﻿



#### 3. 算法性能分析

##### 1）时间复杂度

- 空间复杂度：O(1)（仅需常数级辅助空间）

- 时间复杂度特点：

  - 数学分析困难，尚无确切证明

  - $$
    最坏情况下退化为直接插入排序O(n^2)
    $$

  - $$
    实际效率可达﻿O(n^{1.3})，优于直接插入排序
    $$

- 增量序列影响：

  - 不同增量序列显著影响排序效率
  - 示例中采用d=n/2的递减序列



##### 2）稳定性

- 不稳定证明：
  - 示例序列：6 5 49 49
  - 第一趟d=2时可能交换相同元素49的位置
  - 最终结果中49的相对位置可能改变
- 实现限制：
  - 必须基于顺序表实现（需要随机访问特性）
  - 无法用链表实现（因需按增量快速定位）



## 8.3 交换顺序

### 8.3.2 快速排序

#### 1. 快速排序算法思想

##### 1）快速排序递归工作站 

- 核心思想：通过分治策略将待排序序列划分为独立的两部分，其中一部分的所有元素都比另一部分小

- 示例数组与初始调用 

  - 初始数组：A = [49, 38, 65, 97, 76, 13, 27, 49]，下标范围0-7
  - 首次调用：QuickSort(A, 0, 7)传入整个数组范围
  - 递归条件：当low < high时进入处理，否则说明子表已有序

- Partition函数的作用与实现

  - ![img](https://thumbnail0.baidupcs.com/thumbnail/92bdfbf27t821fe146cec0573cd3d6d4?chkbd=0&chkv=0&dp-callid=0&dp-logid=850948123172263601&expires=8h&fid=1103289404712-250528-962625315342776&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-8heyXKDzn7I3i%2B%2FtauL98KJ1Lww%3D&size=c1080_u1080&time=1749261600&vuk=1103289404712)
  - 枢轴选择：默认取A[low]作为基准元素（如首次调用时pivot=49）

  - 双指针移动：
    - high指针：从右向左扫描，找到第一个< pivot的元素（如找到13）
    - low指针：从左向右扫描，找到第一个pivot>的元素（如找到65）

  - 元素交换：将不符合条件的元素移动到另一端

  - 终止条件：当low == high时确定枢轴最终位置

  - 返回值：返回枢轴元素的最终下标位置

- 递归调用与基准元素确定 

  - 第一层划分：将数组分为[27,38,13]和[76,97,65,49]两部分，基准49最终位置为3
  - 递归工作站：
    - 系统记录函数执行行号（如#96）用于返回后继续执行
    - 每层递归压栈保存low/high值和执行上下文
  - 基准确定：每次划分后基准元素的位置即为其在有序序列中的最终位置

- 左右子表的递归处理 

  - 左子表处理：
    - 范围[0, pivot-1]（如首次划分后处理0-2范围）
    - 子表元素≤3个时直接终止递归（如处理[13]单元素表）
  - 右子表处理：
    - 范围[pivot+1, high]（如首次划分后处理4-7范围）
    - 采用相同方式选择新枢轴（如第二层选择76为基准）
  - 递归深度：示例中最多达到3层递归调用

- 递归结束与排序完成 

  - 终止条件：当所有子表的low >= high时递归结束

  - 执行顺序：

    - 先深度优先处理左子表
    - 返回上层后处理右子表
    - 最终完成整个数组的排序

  - 时间复杂度：
    $$
    平均O(nlogn)，最坏O(n^2)（当数组已有序时）
    $$

  - 空间复杂度：递归栈空间O(logn)



#### 2. 快速排序算法效率分析

##### 1）时间复杂度分析 

**时间效率构成：**由递归层数和每层Partition操作共同决定，总时间复杂度为O(n x 递归层数)

**单层时间复杂度：**每层Partition函数需要扫描当前子表所有元素，时间复杂度不超过﻿O(n)



##### 2）Partition函数执行过程

- 核心操作：通过low和high双指针向中间移动，将元素与枢轴比较并交换位置
- 时间复杂度证明：处理n个元素时，每个元素最多被比较一次，因此时间复杂度严格为O(n)
- 关键步骤：
  - 取第一个元素A[low]作为枢轴pivot
  - high指针从右向左扫描，找到小于pivot的元素移到左端
  - low指针从左向右扫描，找到大于pivot的元素移到右端
  - 最终将pivot存入A[low]位置



##### 3）递归层数与二叉树关系

- 递归树模型：每次划分对应二叉树的一个节点，左右子表对应左右子树

- 深度范围：

  - 最小高度：
    $$
    \lfloor \log_2 n \rfloor +1（完全平衡二叉树）
    $$

  - 最大高度：n（退化成链表）

- 复杂度推导：

  - 最好时间复杂度：
    $$
    O(n\log n)（对应平衡情况）
    $$

  - 最坏时间复杂度：

    
    $$
    O(n^2)（对应极端不平衡情况）
    $$
    

##### 4）最好与最坏情况分析

- 理想情况：每次划分后左右子表长度相近（如初始序列49,38,65,97,76,13,27,49）

  - 递归深度为
    $$
    \log_2 n
    $$

  - $$
    每层时间复杂度O(n)，总复杂度O(n\log n)
    $$

- 最坏情况：初始序列有序或逆序（如1,2,3,4,5,6,7,8）

  - 每次划分极度不均匀，递归深度达n层

  - 总时间复杂度退化为
    $$
    O(n^2)
    $$

- 空间复杂度：与递归深度正相关，最好O(log n)，最坏O(n)



##### 5）快速排序优化思路

- 三数取中法：选取头、中、尾三个位置的元素，取中值作为枢轴

- 随机选取法：随机选择枢轴元素，避免极端情况

- 优化效果：

  - $$
    使划分更均匀，递归深度接近\log_2 n
    $$

  - $$
    即使输入有序，仍能保持O(n\log n)的平均时间复杂度
    $$

- 实际性能：在内部排序算法中平均性能最优，实际应用更接近最好情况而非最坏情况



#### 3. 快速排序稳定性

- 不稳定性证明：通过三元素示例演示，当枢轴元素为0号元素时，原序列中带下划线的2经过划分后位置发生改变（从左侧移至右侧），说明相等元素的相对位置可能改变
- 关键现象：在划分过程中，当遇到与枢轴相等的元素时，算法会跳过移动（如示例中的相等元素），但最终可能导致相同元素顺序改变



## 8.4 选择排序

### 8.4.1 简单选择排序

算法分类: 属于选择排序大类，包含简单选择排序和堆排序两种主要算法

核心思想: 每一趟在待排序元素中选取关键字最小（或最大）的元素加入有序子序列



处理流程:

- 初始状态：所有元素无序
- 第1趟：扫描找到最小元素13，与首位交换
- 第2趟：在剩余元素中找最小27，交换到第2位
- 第3趟：找到最小38，交换到第3位
- 第4趟：遇到两个49时，优先选择靠左的49
- 共需n-1趟处理（n为元素个数）



#### 1.算法实现

```c
void SelectSort(int A[], int n){
    for(int i=0; i<n-1; i++){ //n-1趟处理
        int min = i; //记录最小元素位置
        for(int j=i+1; j<n; j++) //在A[i...n-1]中找最小
            if(A[j] < A[min]) min = j;
        if(min != i) swap(A[i], A[min]); //交换
    }
}
```

交换操作: 使用三次元素移动完成交换，封装为swap函数



#### 2.算法性能分析

**空间复杂度:**O(1)，仅需常数个辅助变量

**时间复杂度:**

- 无论初始有序、逆序还是乱序，都必须进行n-1趟处理

- 关键字对比次数：
  $$
  (n-1)+(n-2)+...+1 = \frac{n(n-1)}{2}次
  $$

- 最终时间复杂度：
  $$
  O(n^2)
  $$
  

#### 3.算法稳定性分析

不稳定性证明:

- 示例序列：2,2,1
- 第1趟处理后：1与第一个2交换，导致两个2的相对位置改变
- 最终结果：1,2,2（第二个2实际是原序列的第一个2）



- 核心原理: 每趟选取最小元素加入有序序列
- 必须特性: 必须进行n-1趟处理
- 空间效率:O(1)的额外空间
- 时间效率: 固定O(n^2)时间复杂度
- 稳定性: 属于不稳定排序算法
- 适用性: 既适用于顺序表也适用于链表结构



## 8.5 归并排序、基数排序和计数排序

### 8.5.1 归并排序

#### 1. 归并概念

**定义:** 归并（Merge）指的是把两个或多个已经有序的序列合并成一个有序序列的过程。



#### 2. 二路归并

**定义:** 二路归并是指将两个有序序列合并成一个有序序列的过程。

**操作:** 在二路归并中，通过对比两个指针所指的元素，选择较小的一个放入新序列中，直到所有元素都合并完成。



#### 3. 四路归并

**定义:** 四路归并是指将四个有序序列合并成一个有序序列的过程。

**操作:** 在四路归并中，需要设置四个指针，每次从四个元素中选出最小的一个放入新序列中，这需要进行三次关键字对比。

**对比次数:** 对于m路归并，选出最小元素至少需要对比m-1次关键字。



#### 4. 归并排序

##### 1）例题:归并排序手算模拟

- ![img](https://thumbnail0.baidupcs.com/thumbnail/5d1766b3bs5e25974026f193181b3751?chkbd=0&chkv=0&dp-callid=0&dp-logid=1250987933787768672&expires=8h&fid=1103289404712-250528-123002330329338&ft=image&quality=100&rt=pr&sign=FDTAER-DCb740ccc5511e5e8fedcff06b081203-U2ydpZBPROcUmOx2ZW0HDaUGRBQ%3D&size=c1080_u1080&time=1749265200&vuk=1103289404712)
- 思路:
  - 初始序列中的每个元素看作是一个已排序的部分。
  - 第一趟归并：相邻的两个部分进行二路归并。
  - 第二趟归并：基于第一趟的结果，再次进行二路归并。
  - 最后一趟归并：将两个有序子序列合并成整体有序序列。



##### 2）代码实现 ﻿

```c
int *B=(int *)malloc(n*sizeof(int)); //辅助数组B

//A[low_mid]和A[mid+L_high]各自有序，将两个部分归并
void Merge(int A[],int low,int mid,int high){
    int i,j,k;
    for(k=low;k<=high;k++)
    	B[k]=A[k];    //将A中所有元素复制到B中
    for(i=low,j=mid+1,k=i;j<=mid&&j<=high;k++){
    	if(B[i]<=B[j])
    		A[k]=B[i++];    //将较小值复制到A中
    	else
    		A[k]=B[j++];
    }//for
    while(i<=mid)  A[k++]=B[i++];
    while(j<=high)  A[k++]=B[j++];
```

- 核心操作: 将数组内的两个有序序列归并为一个。
- 代码逻辑:
  - 定义辅助数组B，将A中元素复制到B中。
  - 使用两个指针i和j分别指向两个有序子序列的起始位置。
  - 对比B[i]和B[j]，将较小值复制到A中，并移动相应指针。
  - 处理剩余元素，将未处理完的子序列元素复制到A中。



##### 3）归并排序完整代码

```c
int *B=(int *)malloc(n*sizeof(int)); //辅助数组B

//A[low...mid]和A[mid+1...high]各自有序，将两个部分归并
void Merge(int A[],int low,int mid,int high){
    int i,j,k;
    for(k=low;k<=high;k++)
    	B[k]=A[k];    //将A中所有元素复制到B中
    for(i=low,j=mid+1,k=i;i<=mid&&j<=high;k++){
    	if(B[i]<=B[j])
    		A[k]=B[i++];    //将较小值复制到A中
    	else
    		A[k]=B[j++];
    }//for
    while(i<=mid)  A[k++]=B[i++];
    while(j<=high)  A[k++]=B[j++];
}

void MergeSort(int A[],int low,int high){
    if(low<high){
    	int mid=(low+high)/2;    //从中间划分
    	MergeSort(A,low,mid);    //对左半部分归并排序
    	MergeSort(A,mid+1,high);//对右半部分归并排序
    	Merge(A,low,mid,high);    //归并
    }//if
}
```

**递归实现:**

- 将无序序列从中间拆分，分别对左右部分递归进行归并排序。
- 左右部分有序后，调用Merge函数进行归并。

- 终止条件: 当序列中只剩一个元素时，递归终止，该序列自然有序。
- 稳定性: 归并排序是稳定的排序算法，因为相等元素会保持原有顺序。



#### 5. 算法效率分析

##### 1）归并排序的“归并树”形态

归并树形态: 归并排序的示意图形态上像一棵倒立的二叉树，也称为归并树。



##### 2）归并排序的趟数与时间复杂度 ﻿

**归并排序趟数:** 归并排序的趟数等于归并树的高度h减1，即h-1。

**时间复杂度计算:** 二叉树的第h层最多有
$$
2^{h-1}
$$
个结点，n个元素进行二路归并排序，应满足
$$
n \leq 2^{h-1}，即h-1 = \lceil \log_2 n \rceil。
$$
所以归并排序的总趟数为
$$
\lceil \log_2 n \rceil。
$$
**总体时间复杂度:** 每一趟归并的时间复杂度为O(n)，总趟数为
$$
\lceil \log_2 n \rceil，
$$
所以算法总体时间复杂度为
$$
O(n \log_2 n)。
$$


##### 3）每趟归并的时间复杂度分析

每趟归并时间复杂度: 无论是哪一趟归并，所需的关键字对比次数都是O(n)数量级。例如，最后一趟归并需要对比的关键字次数最多为n-1次，第一趟归并所需的关键字对比次数约为n/2。



##### 4）归并排序的空间复杂度

**空间复杂度:** 归并排序的空间复杂度主要来自于辅助数组b，其长度为n，所以空间复杂度为O(n)。递归调用带来的
$$
空间复杂度为O(\log_2 n)，
$$
但相比O(n)可忽略不计。



##### 5）归并排序的稳定性

**稳定性:** 归并排序是稳定的算法。当对两个连续的有序子序列进行归并时，若两边同时出现关键字值相等的情况，会优先让靠左边的元素合并进去。



> **归并排序核心:** 如何把两个已经有序的子序列合并到一起。
>
> **算法步骤:**
>
> - 如果low小于high，从中间点mid切分成左右两部分。
> - 分别对左半部分和右半部分递归进行归并排序。
> - 对左右两个有序子序列进行一次merge操作。
>
> - 时间复杂度:
>   $$
>   O(n \log_2 n)，
>   $$
>   与堆排序和快速排序同样优秀。
>
> - 应用: 内部排序通常采取二路归并策略，外部排序会使用更多路的归并排序。
