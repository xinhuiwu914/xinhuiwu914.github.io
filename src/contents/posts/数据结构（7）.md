---
title: 数据结构-7 #标题
published: 2025-06-04 #发布日期
description: 数据结构学习 #描述
tags: [Markdown, Blogging] #标签
category: 笔记 #分类
draft: false #是否为草稿 （隐藏）
---

# 查找

## 7.1 查找的基本概念

#### 1. 基本概念

##### 1）查找表

- 查找定义：在数据集合中寻找满足某种条件的数据元素的过程
- 查找表组成：由同一类型的数据元素（或记录）组成的数据集合，可以是线性结构、树形结构或图状结构
- 记录别称：数据元素在部分场景中也被称为"记录"



##### 2）对查找表的常见操作

- 基本操作：
  - ①查找符合条件的数据元素
  - ②插入/删除数据元素
- 静态查找表 
  - 定义：仅需进行查找操作，数据元素保持静态不变
  - 典型场景：学生成绩单（成绩录入后不再修改）
- 动态查找表 
  - 定义：除查找外还需支持数据元素的增删操作
  - 设计考量：需同时考虑查找效率和增删操作的实现便利性
  - 典型场景：餐饮订单系统（不断新增/取消订单）



#### 2. 查找算法的评价指标

##### 1）查找长度

定义：单次查找过程中关键字比较的次数



##### 2）平均查找长度

- 计算公式：
  $$
  ASL = \sum_{i=1}^{n} P_i C_i﻿，其中P_i为查找第i个元素的概率，C_i为对应查找长度
  $$

- 默认假设：未说明时各元素查找概率相等

- 二叉排序树示例：

  - 成功查找：

    ﻿ASL = (1*1 + 2*2 + 3*4 + 4*1)/8 = 2.625

  - 失败查找：

    ﻿ASL = (3*7 + 4*2)/9 = 3.22

- 评价维度：需分别计算查找成功和查找失败两种情况下的ASL

- 时间复杂度关系：ASL数量级直接反映算法时间复杂度



## 7.2顺序查找和折半查找

### 7.2.1顺序查找

#### 1. 顺序查找的算法思想

- 基本概念: 顺序查找又称"线性查找"，适用于线性表（包括顺序表和链表）
- 查找方式: 从头到尾或从尾到头依次遍历查找，如查找43时从第一个元素开始逐个比较
- 适用场景: 无论线性表采用顺序存储还是链式存储，顺序查找都适用



#### 2. 顺序查找的实现

- 数据结构: 使用顺序表实现，包含动态数组基址ElemType *elem和表长度TableLen
- 查找过程:
  - 从i=0开始循环，条件为i<ST.TableLen && ST.elem[i]!=key
  - 查找成功返回元素下标，失败返回-1



#### 3. 顺序查找的实现哨兵

- 哨兵机制: 将0号位置作为哨兵，存储待查找的key值
- 实现特点:
  - 数据从下标1开始存储
  - 从表尾向表头查找
  - 查找失败时返回0
- 优点: 无需在循环中判断下标越界，效率略高



#### 4. 查找效率分析

- ASL公式:
  $$
  ASL = \sum_{i=1}^{n} P_i C_i
  $$

- 查找成功:

  - 假设各元素查找概率相等为1/n
  - 平均查找长度为(n+1)/2，时间复杂度O(n)

- 查找失败:

  - 需要比较n+1次（含哨兵）
  - 时间复杂度同样为O(n)



#### 5. 顺序查找的优化

##### 1）对有序表

- 优化原理: 当表中元素有序时，遇到大于(或小于)目标关键字的元素可提前终止查找
- 示例: 查找21时，遇到29>21即可确定查找失败
- ASL改进: 减少查找失败时的比较次数
- 用查找判定树分析ASL 
  - 节点类型:
    - 圆形节点：成功节点，查找长度=所在层数
    - 方形节点：失败节点，查找长度=父节点层数
  - ASL计算:
    - 成功ASL：各成功节点层数×概率之和
    - 失败ASL：各失败节点父节点层数×概率之和



##### 2）被查概率不相等

- 优化策略: 将被查概率大的关键字放在靠前位置
- 效果: 降低查找成功的ASL
- 局限性: 会破坏元素有序性，增加查找失败的ASL
- 适用场景: 适合查找成功概率远高于失败的场景



### 7.2.2折半查找

#### 1. 折半查找的算法思想

##### 1）折半查找的定义

- 别称: 又称"二分查找"
- 适用条件: 仅适用于有序的顺序表（数组）
- 有序性要求: 表中元素必须按关键字有序排列（递增或递减）
- 存储结构: 必须采用顺序存储结构（数组），因为需要随机存取特性



##### 2）折半查找的执行过程

- 指针初始化: 设置low指向表头（0），high指向表尾（TableLen-1）

- 中间位置计算:
  $$
  mid = \lfloor (low + high)/2 \rfloor
  $$

- 比较逻辑:

  - 若L.elem[mid] == key，查找成功
  - 若L.elem[mid] > key，则high = mid - 1
  - 若L.elem[mid] < key，则low = mid + 1

- 终止条件: 当low > high时查找失败

- 示例过程: 在表长11的表中查找33，经过4次比较后成功



##### 3）折半查找的实现

代码基于升序排列，降序排列需调整比较条件

链表无法实现折半查找，因其不具备随机存取特性



##### 4）查找效率分析

- 成功查找:

  - 
    $$
    最多需要\lceil \log_2(n+1) \rceil次比较
    $$

  - 平均查找长度(ASL)计算：各层比较次数×该层结点数/总结点数

- 失败查找:

  - 失败结点数为n+1个
  - ASL计算：各层比较次数×该层失败结点数/总失败结点数

- 时间复杂度:
  $$
  O(\log_2 n)
  $$
  

5）折半查找判定树的构造 

- 推演折半查找判定树 

- - 构造规则:
    - 奇数个元素：mid分隔后左右两部分元素个数相等
    - 偶数个元素：mid分隔后左半部分比右半部分少一个元素
    - 对于任何结点：右子树结点数-左子树结点数=0或1
  - 树的性质:
    - 是平衡二叉排序树（AVL树）
    - 满足二叉排序树定义：左<中<右
    - 失败结点数=n+1（等于成功结点的空链域数量）
  - 构造练习:
    - 1个元素：单结点树
    - 2个元素：根结点+右子树
    - 3个元素：根结点+左右子树各1个
    - 4个元素：根结点+左1右2



##### 6）折半查找的查找效率

- 树高计算:
  $$
  h = \lceil \log_2(n+1) \rceil（不含失败结点）
  $$

- 时间复杂度分析:

  - 最坏情况下比较次数不超过树高h

  - 时间复杂度为
    $$
    O(\log_2 n)
    $$

- 效率优势: 远优于顺序查找的O(n)时间复杂度



### 7.2.3分块查找

#### 1. 算法思想

##### 1）分块查找定义

- 基本概念：分块查找又称索引顺序查找，是结合顺序查找和折半查找优点的查找算法
- 数据结构特点：
  - 块内无序：每个分块内的元素可以无序存放
  - 块间有序：各分块之间的关键字范围保持有序（递增或递减）
  - 索引表结构：包含每个分块的最大关键字和存储区间范围（low, high）
- 存储实现：
  - 索引表使用结构体数组存储，包含maxValue、low、high三个字段
  - 实际元素存储在顺序表List中



##### 2）分块查找查找过程

索引表查询：先在索引表中确定待查记录所属分块（可顺序/折半查找）

块内查询：在确定的分块内进行顺序查找



##### 3）折半查找过程

折半查找特点：利用索引表有序特性，提高查找效率



关键注意：

- 当目标关键字不在索引表中时，最终在low所指分块查找
- 若low超出索引表范围，则直接判定失败



#### 2. 查找效率分析

##### 1）分块查找的平均查找长度（ASL）计算 

计算方法：对于14个元素的查找表，每个元素被查概率为
$$
\frac{1}{14}﻿。
$$
计算每个元素查找所需的关键字对比次数，再乘以概率相加。



##### 2）顺序查找索引表的ASL分析

特点：分析过程相对简单，只需模拟查找过程计算对比次数。



##### 3）折半查找索引表的ASL分析

分析过程较复杂



##### 4）均匀分块情况下的ASL计算

- 假设条件：长度为n的查找表均匀分为b块，每块s个元素（n=b×s﻿）

- 顺序查找ASL公式：

  - 索引表：
    $$
    \frac{b+1}{2}
    $$

  - 分块内：
    $$
    \frac{s+1}{2}
    $$

  - 总和：
    $$
    ASL=\frac{b+1}{2}+\frac{s+1}{2}=\frac{1}{2}(s+1+\frac{n}{s})
    $$
    

##### 5）使ASL最小的分块方法

- 优化方法：对ASL公式关于s求导，令导数为零

- 最优解：
  $$
  当s=\sqrt{n}﻿时，ASL取得最小值
  $$

- 最小ASL值：
  $$
  \sqrt{n}+1
  $$
  

##### 6）折半查找索引表与顺序查找块内元素的ASL

公式：
$$
ASL=\lceil\log_2(b+1)\rceil+\frac{s+1}{2}
$$

> 索引表不包含目标关键字时，折半查找终止于low>high，需在low所指分块查找



## 7.5散列（Hash）表

### 7.5.1 散列表的基本概念

散列表：根据关键字计算存储地址的数据结构

散列函数：建立关键字→地址的映射关系

同义词：映射到同一地址的不同关键字

冲突：插入位置已被占用的情况



#### 1. 散列表和散列函数 

散列表（哈希表）：是一种特殊的数据结构，其特点是可以根据数据元素的关键字计算出它在表中的存储地址。

散列函数：建立了关键字到存储地址的映射关系，数学表达式为
$$
\mathrm{Addr} = \mathrm{H}(\mathrm{key})﻿。
$$

- 工作原理示例：

  - 假设散列表长度为13，散列函数为
    $$
    H(key)=key\%13
    $$

  - 插入元素19：
    $$
    19\%13=6
    $$
    → 存储在下标6的位置

  - 插入元素14：
    $$
    14\%13=1$
    $$
    → 存储在下标1的位置

  - 插入元素23：
    $$
    23\%13=10
    $$
    → 存储在下标10的位置

- 查找操作：

  - 查找19：计算19%13=6，直接检查下标6位置
  - 查找16：计算16%13=3，检查下标3位置为空，查找失败
  - 理想情况下查找时间复杂度为O(1)



#### 2. 冲突和同义词 

冲突定义：当插入新元素时，根据散列函数计算出的存储地址已被其他元素占用的情况。

同义词：在同一个散列函数下，被映射到相同地址的不同关键字。



示例：

- 继续插入元素1：1\%13=1，但下标1位置已有元素14
- 此时1和14在该散列函数下是同义词
- 冲突的发生取决于散列函数的选择



#### 3. 如何减少冲突

核心思路：构造更合适的散列函数，使关键字尽可能映射到不同地址。

示例改进：

- 原函数
  $$
  H(key)=key\%13
  $$
  导致1和14冲突

- 改为
  $$
  H(key)=key\%12后：
  $$

  - 19→7，14→2，23→11，1→1
  - 不再发生冲突

局限性：无论如何构造散列函数，冲突都不可避免（如插入13时13\%12=1，仍会与1冲突）



#### 4. 若冲突无可避免，如何处理冲突

##### 1）拉链法

- 原理：将所有同义词存储在同一个链表中
- 别名：又称链接法或链地址法
- 优点：可以处理任意数量的同义词冲突



##### 2）开放定址法

- 原理：当冲突发生时，为元素寻找另一个空闲位置
- 关键问题：需要确定寻找空闲位置的规则



### 7.5.2 散列函数的构造方法

#### 1. 设计散列函数时应该注意什么

##### 1）定义域必须涵盖所有可能出现的关键字

- 定义域: 散列函数的定义域必须涵盖所有可能出现的关键字。例如，散列表长度为13，关键字可能为任一整数（正或负），若散列函数为
  $$
  H(key)=\sqrt{key}\%13
  $$
  ，则不支持负值关键字。

  

##### 2）值域不能超出散列表的地址范围

- 值域: 散列函数的值域不能超出散列表的地址范围。例如，散列表地址范围为0到12，若散列函数为
  $$
  H(key)=key\%15
  $$
  ，则可能映射到非法地址13和14。

  

##### 3）尽可能减少冲突 

- 冲突: 散列函数计算出的地址应尽可能均匀分布在整个地址空间，以减少冲突。例如，若散列函数为
  $$
  H(key)=key*13\%13
  $$
  ，则所有关键字都会被映射到地址0，导致冲突。

  

##### 4）散列函数应尽量简单

- 简单性: 散列函数应尽量简单，以便快速计算出任意关键字对应的散列地址。例如，若散列函数涉及阶乘运算，如
  $$
  H(key)=key!\%13
  $$
  ，则计算耗时较长，效率低下。

  

#### 2. 除留余数法

- 方法: 用关键字对一个不大于散列表表长且最接近或等于该表长的质数p取余，即
  $$
  H(key)=key\%p
  $$
  

- 质数选择: 质数p的选择是为了使散列地址分布更均匀，从而减少冲突。例如，散列表表长为13，则p取13；表长为15，则p取不大于15的最大质数13。

  

##### 1）为什么除留余数法要对质数取余

原因: 对质数取余可以使散列地址分布更均匀。因为质数只能被1和它本身整除，所以与关键字进行取余运算时，结果受公因子影响较小，分布更均匀。

例如，对合数8取余时，关键字若为偶数，则结果只能为0、2、4、6，而对质数7取余时，关键字分布更均匀。



#### 3. 直接定址法

- 方法: 直接定址法通过线性方程将关键字映射到散列地址，
  $$
  即H(key)=key或﻿H(key)=a*key+b
  $$
  ，其中a和b为常数。

- 适用场景: 适用于关键字分布基本连续的场景。例如，存储连续学号的学生信息，可以用学号减第一个学号作为散列地址。

- 注意: 若关键字分布不连续，可能造成存储空间浪费。



#### 4. 数字分析法

- 方法: 选取关键字中数码分布较为均匀的若干位作为散列地址。
- 适用场景: 适用于关键字集合已知，且关键字的某几个数码位分布均匀的场景。例如，存储手机用户信息时，可以选取手机号码末尾四位作为散列地址。



#### 5. 平方取中法 

- 方法: 取关键字的平方值的中间几位作为散列地址，具体取多少位视实际情况而定。
- 适用场景: 适用于关键字的每位取值都不够均匀的场景。例如，存储汽车型号信息时，由于底盘号、发动机号、外观号等分布不均匀，可以采用平方取中法。
- 特性: 平方取中法得到的散列地址与关键字的每位都有关系，因此散列地址分布比较均匀。



### 7.5.3 处理冲突的方法

#### 1. 拉链法 

##### 1）散列表的插入操作

- 操作步骤：

  - 计算地址：根据散列函数
    $$
    H(key)=key\%13
    $$
    计算新元素的散列地址

  - 插入链表：将新元素插入对应地址的链表，可采用头插法或尾插法（默认头插法）

- 示例过程：

  - 初始空表：长度为13的散列表包含13个空链表头指针
  - 插入19(19%13=6)、14(14%13=1)、23(23%13=10)后形成三个非空链表
  - 插入1(1%13=1)时使用头插法，插入到14所在链表的头部
  - 后续插入68(68\%13=3)、20(20\%13=7)等元素同理

##### 2）散列表的查找操作 

- 操作步骤：
  - 计算地址：根据散列函数计算目标元素的散列地址
  - 顺序查找：在对应链表中顺序查找目标元素，直到成功或失败
- 查找长度：
  - 定义：查找过程中关键字对比的次数
  - 统计规则：通常只统计关键字对比次数，空指针对比不计入
  - 特殊情况：空链表的查找长度为0（仅对比空指针）

##### 3）散列表的删除操作

操作步骤：

- 计算地址：根据散列函数计算目标元素的散列地址
- 查找元素：在对应链表中查找目标元素
- 执行删除：若查找成功则删除，否则删除失败



#### 2. 开放定址法 

##### 1）开放定址法的基本原理

- 基本思想：当散列地址发生冲突时，为新元素寻找另一个空闲位置存储。例如元素1初始地址为1，若冲突可存入地址2。

- 开放特性：一个散列地址既可存储同义词（相同散列值的元素），也可存储非同义词（不同散列值的元素），因此称为"开放"定址法。

- 数学表达：第i次冲突时的地址计算公式为
  $$
  H_i = (H(key) + d_i) \% m
  $$
  ，其中﻿H(key)为初始地址，
  $$
  d_i
  $$
  为偏移量，m为表长。



##### 2）四种常用的探测序列 

- 线性探测法 

  - 插入与查找过程

    - 探测规则：
      $$
      d_i序列为0,1,2,3,...（即依次向后探测相邻位置）
      $$

    - 插入示例：插入元素1时，初始地址1冲突→探测地址2→地址3→地址4（成功插入）

    - 查找特点：查找失败条件为遇到空单元；查找成功条件为关键字匹配

    - 保证性：只要散列表有空位，线性探测法必定能找到

- 平方探测法 

  - 插入与查找过程

    - 探测规则：
      $$
      d_i序列为0,1,-1,4,-4,9,-9,...（即交替探测正负平方数位置）
      $$

    - 插入示例：插入元素1时，地址1冲突→地址2→地址0→地址5（成功插入）

    - 优势：相比线性探测能减少"聚集"现象

- 双散列法 

  - 插入与查找过程

    - 探测规则：
      $$
      d_i = i \times hash_2(key)，需设计第二个散列函数
      $$

    - 示例函数：
      $$
      hash_2(key) = 13 - (key\%13)
      $$

    - 插入过程：插入元素1时，地址1冲突→计算
      $$
      hash_2(1)=12
      $$
      →探测地址0→地址12→地址11（成功插入）

    - 特点：不同关键字对应不同探测序列，减少规律性

- 伪随机序列法 

  - 插入与查找过程
    - 探测规则：采用程序员预设的伪随机序列（如0,5,3,1,...）
    - 插入示例：插入元素1时，地址1冲突→按序列探测地址6→地址4（成功插入）
    - 灵活性：序列可自由设计，但需保证能覆盖所有地址



#### 3. 删除一个元素 

- 前提条件：题目一定会说明具体采用哪种探测序列（线性探测法、平方探测法、双散列法、伪随机序列法）
- 基本步骤：
  - 给定要删除元素的关键字
  - 先查找该关键字
  - 查找成功才能删除，查找失败则删除失败
- 通用原则：无论采用哪种具体方法，删除步骤都相同



#### 4. 特别注意

##### 1）关于删除操作

- 关键问题：不能物理删除元素，否则会截断探测路径
- 示例说明：
  - 删除元素15时，若直接清空位置#3
  - 后续查找元素1时，探测到空位会错误判断查找失败
- 正确做法：
  - 进行逻辑删除，用特殊标记（如flag=1）表示已删除
  - 保证探测路径不会中断
- 适用范围：适用于所有四种探测方法（线性/平方/双散列/伪随机）



##### 2）逻辑删除的影响

- 主要缺点：
  - 查找效率低下：需要遍历大量已删除位置
  - 空间利用率虚假：表看起来很满实则很空
- 解决方案：
  - 不定期整理散列表数据
  - 将元素移回初始散列地址
  - 物理清空其他位置
- 插入优化：
  - 新元素可插入到逻辑删除的位置
  - 例如插入14可放入标记为已删除的位置#1



#### 5.拓展 ﻿

##### 1. 线性探测法的"探测覆盖率"

- 探测公式:
  $$
  H_i = (H(key) + d_i)\%m$﻿，其中d_i为线性增量序列
  $$

- 完全覆盖性: 最多发生m-1次冲突即可探测完整个散列表

- 实例说明: 初始地址为5时，探测序列为5→6→7→0→1→2→3→4

- 插入保证: 只要散列表有一个空闲位置，一定能探测到并插入成功

##### 2. 平方探测法的"探测覆盖率" 

- 增量序列:
  $$
  d_i = 0^2,1^2,-1^2,2^2,-2^2,...,k^2,-k^2，其中k \leq m/2
  $$

- 覆盖范围: 通常只能覆盖散列表约一半的位置

- 完全覆盖条件: 当表长m为形如4g+3的素数时(如7,19,23等)，可以完全覆盖

- 实例对比:

  - m=8时只能覆盖部分位置(如初始地址5的探测序列为5→6→4→1→...)
  - m=7时可以完全覆盖所有位置

##### 3. 双散列法的"探测覆盖率" 

- 探测公式:
  $$
  d_i = i \times hash_2(key)
  $$

- 关键因素: 
  $$
  第二个散列函数hash_2(key)的设计合理性
  $$

- 完全覆盖条件:
  $$
  hash_2(key)的值必须与表长m互质
  $$

- 常用设计方法:

  - 令m为质数

  - $$
    采用hash_2(key) = m - (key\%m)
    $$

- 实例对比:

  - $$
    hash_2(key)=2时只能探测奇数位(1,3,5,7)
    $$

  - $$
    hash_2(key)=3时可以完全覆盖所有位置
    $$

##### 4. 伪随机序列法的"探测覆盖率" ﻿

- 序列特性: 由程序员人为设计的伪随机序列

- 覆盖特性: 完全取决于序列设计是否合理

- 实例对比:

  - $$
    序列d_i=0,2,4,6,8,10,12,14只能覆盖部分位置
    $$

  - $$
    序列d_i=0,-5,-2,1,-4,-1,2,-3可能覆盖全部位置
    $$

    

##### 5. 四种探测序列的"探测覆盖率"总结

- 线性探测法: 总能完全覆盖，最多m-1次冲突即可探测全部单元

- 平方探测法:

  - 通常至少覆盖一半单元
  - 当m=4g+3的素数时可完全覆盖

- 双散列法:

  - $$
    当hash_2(key)与m互质时可完全覆盖
    $$

  - $$
    常用质数表长和特定hash_2设计保证
    $$

- 伪随机序列法: 完全取决于序列设计合理性

- 唯一保证: 只有线性探测法无条件保证完全覆盖