---
title: 数据结构-2 #标题
published: 2025-05-10 #发布日期
description: 数据结构学习 #描述
tags: [Markdown, Blogging] #标签
category: 笔记 #分类
draft: false #是否为草稿 （隐藏）
---
# 线性表

## 2.1 线性表的定义和基本操作

### 2.1.1 线性表的定义

线性表是具有**相同数据类型**的 n(n≥0) 个数据元素的有限序列，其中 n 为表长。当 n=0 时，线性表是一个空表。

线性表通常表示为：L=(a1,a2,...,an)!

- a1：表头元素（第一个元素）
- an：表尾元素（最后一个元素）
- 除第一个元素外，每个元素有且仅有一个直接前驱。
- 除最后一个元素外，每个元素有且仅有一个直接后继。

#### 线性表的特点

- 表中元素的个数有限。
- 表中元素具有逻辑上的顺序性，表中元素有先后次序。
- 表中元素都是数据元素，每个元素都是单个元素。
- 表中元素的数据类型都相同，这意味着每个元素占有相同大小的存储空间。
  - **注意**：相同大小的存储空间，并不代表数据类型相同。
    - *例如：在 C/C++ 中，`int` 类型占用 4 个字节，`float` 类型也占用 4 个字节。*
- 表中元素具有抽象性，即仅讨论元素间的逻辑关系，而不考虑元素究竟表示什么内容。
  - 为了更容易理解，我们可以这样想：
    - 线性表就像数组，它的每个位置都放着一个东西，而且所有东西占用的空间大小都一样。
    - 至于每个位置具体放什么（数字、文字等），以及这些东西的实际内容长度，线性表并不关心。
    - 在线性表中，如果数组中存放的都是字符串，我们可以认为这些字符串属于相同的数据类型。但是，不同长度的字符串，在内存中占据的存储空间不一定相同。
      - 如果使用固定长度的存储方式，那么每个字符串分配的空间大小是一样的。
      - 如果使用动态分配的存储方式，那么字符串实际占用的空间会根据字符串的长度变化。
    - 更重要的是，线性表关心的是它存储的每个元素的直接大小是否相同。如果直接存储的是固定长度的字符串，或者是指向字符串的指针（指针长度固定），那么就符合线性表的定义。
    - 这样，才能用统一的方式来管理数据，方便进行增加、删除、查找等操作。

### 2.1.2 线性表的基本操作

- **增加**
  - `ListInsert(&L, i, e)`：插入操作。在表 L 中的第 i 个位置上插入指定元素 e。
- **删除**
  - `ListDelete(&L, i, &e)`：删除操作。删除表 L 中第 i 个位置的元素，并用 e 返回删除元素的值。
  - `DestroyList(&L)`：销毁操作。销毁线性线性表，并释放线性表 L 所占用的内存空间。
- **修改**
  - `GetElem(L, i)`：按位查找操作。获取表中第 i 个位置的元素的值。
- **查找**
  - `Length(L)`：求表长。返回线性表的长度，即 L 中数据元素的个数。
  - `LocateElem(L, e)`：按值查找操作。在表中查找具有给定关键字值的元素。
  - `PrintList(L)`：输出操作。按前后顺序输出线性表 L 的所有元素值。
  - `Empty(L)`：判空操作。若 L 为空表，则返回 true，否则返回 false。
- **初始化**
  - `InitList(&L)`：初始化表。构造一个空的线性表。

### 注意

- 基本操作的实现取决于采用哪种存储结构，存储结构不同，算法的实现也不同。
- 符号“&”表示 C++ 语言中的引用调用，在 C 语言中采用指针也可达到同样的效果。（即带回来）
  - **为什么有一些输入带&，有一些不带&？ &L 和 L 的区别，&e 和 e 的区别**
    - 在 C++ 中，函数参数传递有两种主要方式：值传递和引用传递。
    - **值传递**：函数会创建一个变量的副本，对副本的修改不会影响原始变量。
    - **引用传递**：函数接收变量的内存地址，直接修改原始变量。
    - `L` 和 `e` 在没有 `&` 的情况下，通常是值传递。`&L` 和 `&e` 中的 `&` 表示引用传递。
    - **为什么有些输入带 `&`，有些不带 `&`？**
      - 取决于函数的设计目的，即函数需要对参数做什么操作。
      - 需要修改原始变量时，使用 `&`。  例如，`ListInsert(&L, i, e)` 需要修改 `L` 本身。
      - 只需要读取原始变量的值时，不使用 `&`。 例如，`Length(L)` 只需要读取 `L` 的内容。
    - **`&L` 和 `L` 的区别**
      - `L`：传递线性表的值（拷贝），函数内的操作不影响原始线性表。
      - `&L`：传递线性表的引用（地址），函数内的操作会直接修改原始线性表。
    - **`&e` 和 `e` 的区别**
      - `e`：传递元素的值（拷贝），函数内的操作不影响原始元素。
      - `&e`：传递元素的引用（地址），函数内的操作会直接修改原始元素。
    - **总结**
      - 当需要修改线性表本身时，使用 `&L`。
      - 当只需要读取线性表时，使用 `L`。
      - 当需要返回元素时，使用 `&e`。
      - 当只需要传入元素时，使用 `e`。

# 2.2 线性表的顺序表示

## 2.2.1 顺序表的定义

### 1. 定义

线性表的顺序存储叫做顺序表

:::note

- 顺序表的特点是: 逻辑顺序与存储的物理顺序相同.

- 起始位置: LOC(A)

- 每个数据元素占的内存空间: sizeof(ElemType)

- 数组下标为i的元素的内存地址: LOC(A)+i*sizeof(ElemType)

- 线性表中元素的位序是从**1**开始的，而数组元素的下标是从**0**开始的

  :::

2. 静态分配的存储结构描述

```c
#define MaxSize 50 //定义最大容量
typedef struct{
    ElemType data[MaxSize]; //数组存储元素
    int length; //当前已经存储的元素个数，即当前长度
}SqList; //定义顺序表类型(也就是给这个结构体取个名字)

SqList L; //声明顺序表变量
```

:::note
静态分配的容量是固定的.

内存是一开始就分配好的.

随机存取.
:::

3. 动态分配的存储结构描述

```c
#define InitSize 50 //定义初始容量
typedef struct{
    ElemType *data; //动态分配数组的指针,指向第0个元素的内存地址.
    int MaxSize,length;//最大容量和当前个数.
}SeqList;//定义动态顺序表类型

SeqList L; //声明动态顺序表变量
```

```c
L.data = (ElemType*)malloc(sizeof(ElemType)*InitSize)
/*
c语言用malloc动态分配空间
sizeof(ElemType)*InitSize : 需要分配的内存大小,单个元素的大小*元素个数
(ElemType*) : 类型转换,将malloc返回的void*类型转化为ElemType*类型
也就是说,malloc会为你留出一块空地,你需要用类型转化,规定这块地方建什么房子
*/
```

```cpp
L.data = new ElemType[InitList]
/*
cpp用new分配空间
InitList : 数组大小

*/
```


:::note
动态内存的容量是不固定的.

内存是可以动态变化的.

随机存取
:::

:::warning[动态分配vs链表]
动态分配依然在物理地址上依然是连续的,

一旦数组占满,就会尝试寻找一块更大的连续空间,

再将原来的数组拷贝过去.

如果找不到更大的连续空间,就会报错 "内存分配失败"

可以这样理解,动态分配顺序表,是一个条状连续空间.

链表是一个个小方块相连.
:::

:::note[内存碎片]
连续空间的分配,会造成内存中有一些小块内存,

这些小块内存永远得不到顺序表的使用,就叫做外部碎片.

链表可以有效利用这些外部碎片.

如果为顺序表分配了很大的空间,但是实际只使用了一部分,

并没有被使用的那部分,就是内部碎片.
:::

3. 特点

优点:

- 随机存取

> 因为顺序存储,所以不需要从头开始遍历,可以直接找到对应元素的地址.

- 存储密度高

> 只需要存数据元素就行,不需要存指针.

缺点:

- 在中间插入或者删除元素时,需要移动所有后方元素.

- 连续内存分配不灵活

## 2.2.2 顺序表上基本操作的实现

### 1.初始化

静态分配

```c
#define MaxSize 50 //定义最大容量
typedef struct{
    ElemType data[MaxSize]; //存储数据的数组
    int length; //当前长度
}SqList; //顺序表类型定义

SqList L; //声明顺序表变量

void InitList(SqList &L){
    L.length = 0; //初始化长度为0
}
```

动态分配

```c
#define InitSize 50 //初始容量
typedef struct{
    ElemType *data; //指向动态分配数组的指针
    int MaxSize,length;//最大容量和当前长度
}SeqList;//动态顺序表类型定义

SeqList L; //声明动态顺序表变量

void InitList(SeqList &L){
    L.data = (ElemType*)malloc(InitSize*sizeof(ElemType));//分配初始空间
    L.length = 0;//初始化长度为0
    L.MaxSize = InitSize;//设置最大容量
}
```

### 2. 插入

静态分配

```c
bool ListInsert(SqList &L,int i,ElemType e){
    if(i<1||i>L.length+1)//检查插入位置是否合法
        return false;
    if(L.length>=MaxSize)//判断容量不足
        return false;
    for(int j=L.length;j>=i;j--)//从后往前,移动后方所有元素
        L.data[j]=L.data[j-1];
    L.data[i-1]=e;//插入元素
    L.length++;//长度加1
    return true;
}
```

动态分配

```c
// 动态顺序表的插入操作
bool ListInsert_Dynamic(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {
        return false; // 检查插入位置是否合法
    }
    if (L.length >= L.capacity) {
        // 容量不足，需要扩容
        ElemType *newData = new ElemType[L.capacity * 2]; // 通常扩容为原来的两倍
        if (!newData) {
            return false; // 扩容失败
        }
        // 将原数据复制到新数组
        for (int j = 0; j < L.length; j++) {
            newData[j] = L.data[j];
        }
        delete[] L.data;   // 释放旧的内存
        L.data = newData;  // 指向新的数组
        L.capacity *= 2; // 更新容量
    }
    // 从后往前移动元素
    for (int j = L.length; j >= i; j--) {
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e; // 插入元素
    L.length++;        // 长度加1
    return true;
}
```

:::warning[区分下标和第i个元素]
下标从0开始;

第i个元素从1开始;
:::

### 3. 删除

```c
bool ListDelete(SqList &L;int i;ElemType &e){
    if(i<1||i>L.length)//检查删除位置是否合法
        return false;
    e = L.data[i-1];//将要删除的元素赋值给e
    for(int j=i;j<L.length;j++)//从前往后前移元素.
        L.data[j-1]=L.data[j];
    L.length--;//长度减1
    return true;
}
```


### 4. 按值查找

```c
int LocateElem(SqList L,ElemType e){
    int i;
    for(i=0;i<n;i++)//循环遍历查找,没啥好说的.
        if(L.data[i]==e)
            return i+1;
    return 0; //没找到,退出循环,返回0
}
```

# 2.3 线性表的链式表示

## 2.3.1 单链表的定义

### 1. 定义

链式存储的线性表也称单链表

:::note[单链表]
通过一组任意的存储单元来存储线性表中的数据元素

对于链表节点,要存储数据单元,还要存一个后继的指针

非随机存储,要查找一个节点,必须从头开始遍历
:::

:::note[单链表]
缺点：不可随机存取，要耗费一定空间存取指针。存储密度低。

优点：不要求大片连续空间，改变容量方便
:::

### 2. 单链表的节点数据类型

①

```c
typedef struct LNode{//定义结构体
    ElemType data;//要存的数据元素
    struct LNode *next;//后继节点指针
}LNode, *LinkList;//给数据结构和数组起名.
```

②
```c
typedef (struct LNode) LNode;
LNode *p=(LNode *) malloc (sizeof(LNode));
```

:::note[typedef]

①定义单链表节点类型

②每个节点存放一个数据元素

③指针指向下一个节点
:::

### 3. 头节点和头指针

头节点实际上是对链表的一种优化版本,带头节点的链表有一些优点.

头节点: 带头节点的链表的第一个节点,通常不存储信息

头指针: 不管是哪种版本,都有头指针,指向链表的第一个节点

①LNode *L；//强调返回的是一个节点
②LinkList L；//代码可读性更强，强调这是一个单链表
:::note[优点]

1. 使得第一个数据节点不再特殊,可以和其他节点一样处理.因为如果不带头节点,那么首个数据节点没有上个节点,处理起来会有很多不同,导致链表处理起来都要考虑它的特殊性.

2. 使得空链表不再特殊,可以和非空链表一样处理.因为如果不带头节点,空链表就是NULL,这就导致了特殊化.

本质上,通过增加一个额外的节点,换来了逻辑和代码的简洁性,让更多的情况可以统一处理.见课表P30
:::

## 2.3.2 单链表上基本操作的实现

### 1. 单链表的初始化

带头节点

```c
bool InitList(LinkList &L){
    L=(LNode*)malloc(sizeof(LNode));//创建头节点
    L->next=NULL;//初始化头节点指针域，空表，防止脏数据
    return true;
}
```

不带头节点

```c
bool InitList(LinkList &L){
    L=NULL;//初始化头指针为空，空表，防止脏数据
    return true;
}
```

判断单链表是否为空
①
```c
bool Empty (LinkList L){
    if (L==NULL)
        return true;
    else
        return false;
}

```

②
```c
bool Empty (LinkList L){
    return (L==NULL);
} 
```

### 2. 求表长

```c
int Length(LinkList L){
    LNode *p=L->next; //带头节点就->next,不带就不->next
    int len=0;
    while(p!=NULL){
        p=p->next;
        len++;
    }
    return len;
}
```

### 3. 按序号查找结点

①
```c
//按位查找，返回第i个元素（带头结点）
LNode *GetElem(LinkList L,int i){
    if (i<0)
        return NULL;//不合法，返回NULL
    LNode *p;//指针P指向当前扫描到的节点
    int j=0;//当前指针P指向的第几个节点
    p=L;//L指向头节点，头节点是第0个节点（不存数据）
    while (p!=NULL && j<i){//循环找到第i个节点
        p=p->next;
        j++;
    }
    return p;//返回第i个节点的指针或NULL
    //反馈，回收指针
}
```

②王道书版本
```c
LNode *GetElem(LinkList L,int i){
    LNode *p=L->next; //带头节点就->next,不带就不->next
    j=1;
    while(p!=NULL){
        if(j==i)
            return p;
        p=p->next;
        j++;
    }
    return NULL
    while (p!=NULL && j<i){//循环找到第i个节点
        p=p->next;
        j++;
    }
    return p;
}
```

:::note[时间复杂度]
平均时间复杂度：O（n）
:::

### 4. 按值查找元素

①
```c
LNode *LocateElem(LinkList L,ElemType e){
    LNode *p=L->next; //带头节点就->next,不带就不->next
    //从第一个节点开始查找数据域为e的节点
    while(p!=NULL){
        if(p->data=e)
            return p;
        p=p->next;
    }
    return NULL;
}
```

②王道书版本
```c
LNode *LocateElem(LinkList L,ElemType e){
    LNode *p=L->next; //带头节点就->next,不带就不->next
    while(p!=NULL && p->data!=e)    //从第一个节点开始查找数据域为e的节点
        p=p->next;
    return p;   //找到后返回该节点指针，否则返回NULL
}
```

:::note[时间复杂度]
平均时间复杂度：O（n）
:::

### 5. 插入节点操作

```c
bool ListInsert(LinkList &L;int i;ElemType e){
    LNode *p=L->next;//带头节点就->next,不带就不->next
    j=1;
    while(p!=NULL){
        if(j==i){
            LNode *s=(LNode*)malloc(sizeof(LNode));//创建新节点
            s->data=e;//赋值
            s->next=p->next;//插入操作
            p->next=s;
            ElemType temp=p->data;//交换数据
            p->data=s->data;
            s->data=temp;
            return true;
        }
        p=p->next;
        j++;
    }
    return false;
}
```

### 6.删除节点操作

```c
bool ListDelete(LinkList &L,int i,ElemType &e){
    LNode *p=L->next;//带头节点就->next,不带就不->next
    j=1;
    while(p!=NULL){
        if(j==i){
            ElemType e=p->data;//保存要删除的元素
            p->data=p->next->data;//用后继节点数据覆盖
            p->next=p->next->next;//删除后继节点
            free(p->next);//释放空间
            return true;
        }
        j++;
        p=p->next;
    }
    return false;
}
```

7和8没啥意思,重复的东西,我就不写了.

## 2.3.3 双链表

### 1. 定义

就是比单链表多了前驱的指针.

### 2. 数据结构

```c
typedef struct DNode{//双向链表节点定义
    ElemType data;//数据域
    struct DNode *prior,*next;//前驱和后继指针
}DNode,*DLinklist;
```

### 3. 操作

1. 插入操作

向p和q中间位置插入一个s:

```c
q=p->next;//保存p的后继
p->next=s;//p的后继指向s
s->next=p;//s的后继指向p
q->prior=s;//q的前驱指向s
s->prior=p;//s的前驱指向p
```

2. 删除操作

删除s节点

```c
p=s->prior;//保存s的前驱
q=s->next;//保存s的后继
free(s);//释放s节点
p->next=q;//p的后继指向q
q->prior=p;//q的前驱指向p
```

## 2.3.4 循环链表

### 1. 循环单链表

最后一个节点的指针指向头节点,形成一个循环.

### 2. 训练双链表

比循环单链表多了前驱节点.头节点的前驱是尾节点.

## 2.3.5 静态链表

### 1. 定义:

描述线性表的链式存储结构,指针是数组的相对地址.

:::note[静态链表]

和顺序表一样,也是连续的空间.

其实本质上还是顺序表,只是不再按正常的前后顺序,而是按照next,在这一个数组中乱跳.

每一个节点的next,是下一个节点在数组中的位置.

最后一个节点的next是-1,表示链表结束.
:::

### 2. 数据结构

```c
#define MaxSize 50 //最大容量
typedef struct{
    ElemType data;//数据域
    int next; //静态链表中的指针域
}SLinkList [MaxSize];
```

## 2.3.6 顺序表和链表的比较

### 1. 存取方式

顺序表可以顺序存取,也可以随机存取.
链表只能从前向后遍历.

### 2. 逻辑顺序和物理结构

顺序表:逻辑顺序相邻的,物理结构一定相邻.
链表:不一定,逻辑顺序是由指针链接表示的.

### 3. 查找,插入和删除操作

1. 查找特定元素的位置:
   顺序表:
   有序:O(log2n) <二分法>
   无序:O(n) <遍历>
   链表:O(n) <遍历>

2. 查找特定位置的元素:
   顺序表:O(1) <直接定位>
   链表:O(n) <从前向后遍历>

3. 插入
   顺序表:O(n) <受限于要移动后方元素>
   链表:O(n) <受限于要遍历到要插入的位置>

4. 删除
   顺序表:O(n) <受限于要移动后方元素>
   链表:O(n) <受限于要遍历到要删除的位置>